/*
 * -----------------------
 * --- DEVICE HANDLER ----
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 
 
def clientVersion() {
    return "04.04.02"
}

/**
 * Foscam/Tenvis IP Camera
 *
 * Copyright RBoy Apps, redistribution, reuse or modification of code is not allowed without permission
 * Change log:
 * 2019-01-16 - (v04.04.02) Fix for SD cameras not sending pictures when snap picture is enabled, snap picture is always enabled for SD cameras
 * 2019-01-07 - (v04.04.01) Capture changes to motion detection areas before turning off motion detection incase use made changes using the app while it was armed
 * 2019-01-02 - (v04.04.00) Auto detect area settings from the camera, after setting the detection area on the camera, tap the refresh tile to retrieve/save the setting. Improved pan/tilt controls
 * 2018-12-21 - (v04.03.04) Added R2E to Ambarella chipsets
 * 2018-09-12 - (v04.03.03) Fix text printed in recently tab when motion is detected
 * 2018-09-07 - (v04.03.02) Improve description of options, fix DNS lookup due to ST changes
 * 2018-08-05 - (v04.03.01) Basic switch support for the new ST mobile app and health check
 * 2018-02-20 - (v04.03.00) Use Flip and Mirror status from Camera instead of having the user define them
 * 2018-02-08 - (v04.02.01) Added support for default/custom Ambarella detection area
 * 2017-12-07 - (v04.02.00) Fixed broken ST aysnc http for images and patch for ST blocking Google DNS name resolution
 * 2017-11-01 - (v04.01.00) Added support for sound detection sensitivity level and fixed sound detection on SD cameras
 * 2017-10-25 - (v04.00.00) Moved to callback for hubaction so that IP address can be changed on Camera and getting ready for auto discovery
 * 2017-10-11 - (v03.05.00) Added support for blank passwords. Added command 'center' and corner controls updated GUI, fixed issue with mirror+flip for SD cameras, added support for audio for SD cameras, added support for external IP address for live streaming, added support for automatic detection of presets and upto 6 presets, added support for camera fixed presets and cruises
 * 2017-08-28 - (v03.04.06) Show errors in device events
 * 2017-07-26 - (v03.04.05) Ignore any http(s) in the address field
 * 2017-05-04 - (v03.04.04) Update UI colors to match ST recommendation
 * 2017-02-01 - (v3.4.4) Clean up and support for retrieving image from S3
 * 2017-01-31 - (v3.4.3) Fix for change in ST platform snapshot API
 * 2017-01-23 - (v3.4.2) Disabled capability "Alarm" to avoid confusion, fixed take picture due to changes in the ST platform API's
 * 2017-01-14 - (v3.4.0) Added support for PIR and Motion options and the Amba Chipset/C2, R2, FI9900P camera, added support for cloud uploading, added support for showing error in communication with camera
 * 2016-12-02 - Fixed issue with password special characters in RTSP streams
 * 2016-11-30 - Improved text description
 * 2016-11-22 - Fixed issue with DNS service not working
 * 2016-11-05 - Added support for code version reporting
 * 2016-10-24 - Improved rate limit to block runaway loops, added ability to check for updates
 * 2016-10-07 - Rate limit number of pictures taken to 20 per 60 seconds on request from ST staff
 * 2016-09-06 - Added support for sound detection and clarified setup settings
 * 2016-07-26 - Clarified import of JsonSlurper
 * 2016-07-17 - Clarified IP input is hostname and not URL
 * 2016-07-05 - Clarification, hostnames are only for public DNS hostnames not local LAN
 * 2016-05-24 - Invoke refresh if user has not initialized camera after initial install and started video streaming
 * 2016-05-24 - Disabled imageDataJpeg attribute and storage for now on ST's request
 * 2016-05-24 - Comment out the updated() function since it's causing random issues with some users and being called randomly
 * 2016-05-17 - Clarified RTSP defaults in preferences
 * 2016-04-29 - Take care of bad camera firmware creating malformed XML strings
 * 2016-04-28 - Optimized layout of UI and button for video streaming
 * 2016-04-25 - Only enable mainStream h.264 (but activate subStream MJPEG for SmartTiles) for now since subStream MJPEG has issues with compatibility with ST Phone and subStream h.264 will break SmartTiles
 * 2016-04-23 - Summary is the default tile to show the motion detection on / off in the list of things
 * 2016-04-23 - Added separate RTSP port for C1 and other HD cameras, fix for switching profiles
 * 2016-04-23 - Fix for special characters in the password, fix for changing profiles
 * 2016-04-22 - Provided an option for enabling MJPEG cameras which also supports SmartTiles
 * 2016-04-19 - Added support for Video streaming for HD and SD cameras with Hi and Low res stream options
 * 2016-04-12 - Allow for no password in login (not a recommended practice but allow for it)
 * 2016-04-02 - Updated color for Auto LED off to light blue
 * 2016-04-02 - Fix for left/right/up/down direction when using HDCameras and Flip/Mirror (camera auto compensates)
 * 2016-04-02 - Changed message on motion detection to Motion instead of Alarm to emulate a motion sensor (and blue color)
 * 2016-03-15 - Changed imageDataJpeg to a Base64 string instead of UTF-8 to make it compatible with SmartTiles
 * 2016-03-15 - Fixed updated function
 * 2016-03-12 - Added support for imageDataJpeg attribute to report the JPEG picture as a UTF-8 String
 * 2016-02-28 - When using public hostnames don't convert to public IP, support for reverse proxies
 * 2016-02-14 - Removed unnecessary notifications from activity log
 * 2016-02-06 - Fixed refresh on configuration
 * 2016-02-02 - Add initialization on settings update
 * 2016-01-13 - Fix for "Content is not allowed in prolog" error (due to BOM) in older SD cameras
 * 2016-01-06 - Added option to manually enter detection area in the settings (no leading or trailing & required)
 * 2016-01-02 - Improved layout of buttons
 * 2015-10-11 - Added support to check for SD camera wrong username/password authorization errors
 * 2015-10-03 - Added support to fallback and retry if httpGet fails with hubAction
 * 2015-10-02 - Improve support for public ip address and improved speed of response for picture taking
 * 2015-09-30 - Fixed issue with special characters not working in username and password and preset names
 * 2015-09-30 - Improved settings explanation, added message for error responses from camera
 * 2015-09-19 - Added support for MultiAttribute Tiles
 * 2015-09-19 - Check for invalid IP Address or port and other settings
 * 2015-09-01 - Improved callback motion status update after 10 seconds
 * 2015-08-27 - Added option to reduce light sensitivity for SD cameras
 * 2015-08-24 - Fine tune movements of cameras and communication delays
 * 2015-08-24 - Fix for phantom alarm when turning on sometimes left over from previous alarm
 * 2015-08-23 - Fix for Push notification recurring alarm and improved reliability for SD Camera notifications
 * 2015-08-23 - Enabled support for Push notifications for SD cameras
 * 2015-08-23 - Removed attributes ledState and ledMode and converted to state variables
 * 2015-08-23 - Added support for SD Camera Poll Alarm notifications (push doesn't always work due to 128 character URL limit)
 * 2015-08-23 - Added support for eMail, Motion Sensitivity levels and Snap picture on motion alert for SD cameras
 * 2015-08-22 - Bugfixes for SD Foscam (MJPEG series likes 9810)
 * 2015-08-14 - Added support for Mirror and Flip for SD cameras Video orientation
 * 2015-08-14 - Added support for SD Camera Alarm push notifications
 * 2015-08-13 - Alarm notification for SD cameras is not supported yet, only for HD cameras
 * 2015-08-13 - Fixed the rearm interval to 15 seconds because the ST platform is too slow to communicate the camera and may miss the motion alarm notification
 * 2015-06-21 - Fixed issue with refresh not working
 * 2015-06-21 - Added support for mirroring/Flipping for HD cameras and support for video mirroring/flipping
 * 2015-06-19 - Added attributes ledState and ledMode to definitions
 * 2015-06-18 - Fix for tile names not being restored after pressing
 * 2015-06-17 - Added support for Motion Sensor to report motion - to be used in conjunction with the Foscam Motion Alarm Monitor since we can't poll from device code
 * 2015-06-17 - Enhanced reporting status dynamically, improved communicated reliablility, reduced verbosity of activity logs
 * 2015-06-17 - Added support for getting LED on/off status, simplified LED icons
 * 2015-06-17 - Fixed issue with HD camera's not working due to ST platform changes
 * 2015-03-28 - Fixed missing command siren and both for alarm capability, temp fix for android carousel hang, fixed issue with preset and cruisemap names breaking on android
 * 2015-02-22 - Fix for Alarm and Switch not being updated
 * 2015-02-04 - Presets show names
 * 2015-01-29 - Added options for configuring eMail, local ringer alarm, taking pictures and recording videos for motion detection
 * 2015-01-20 - Cruisemaps now show the names
 * 2015-01-20 - Added support for hostnames (public) instead of ipaddress for device
 * 2015-01-19 - Turning on the strobe function also takes a picture
 * 2015-01-19 - Support configuring motion alarm snap interval and motion sensitivity, added support for using as an Alarm and Switch/Relay Switch to enable monitoring
 */
 
metadata {
	definition (name: "RBoy Foscam IP Camera", namespace: "rboy", author: "RBoy Apps", ocfDeviceType: "oic.d.switch", mnmn: "SmartThings", vid:"generic-switch") {
		capability "Polling"
		capability "Image Capture"
        capability "Relay Switch"
        capability "Switch"
        capability "Refresh"
        capability "Motion Sensor"
        capability "Sensor"
        capability "Video Camera"
        capability "Video Capture"
        capability "Configuration"
        capability "Health Check"
        //capability "Alarm" // Enable this if you want to use use the Camera through the Alarm action to take a picture and turn on monitoring
        
        attribute "alarmStatus", "string"
        attribute "ledStatus", "string"
        attribute "hubactionMode", "string"
        attribute "presetTop", "string"
        attribute "presetBottom", "string"
        attribute "presetLeft", "string"
        attribute "presetRight", "string"
        attribute "preset1", "string"
        attribute "preset2", "string"
        attribute "preset3", "string"
        attribute "preset4", "string"
        attribute "preset5", "string"
        attribute "preset6", "string"
        attribute "mirrorStatus", "number"
        attribute "flipStatus", "number"
        attribute "cameraType", "string"
        attribute "alarmNotifyType", "string"
        attribute "detectionArea", "string"
        attribute "irState", "string"
        attribute "irMode", "string"
        //attribute "imageDataJpeg", "string"
        attribute "codeVersion", "string"
        attribute "dhName", "string"
    
		command "alarmOn"
		command "alarmOff"
		command "toggleAlarm"

		command "toggleLED"
		command "ledOn"
		command "ledOff"
		command "ledAuto"
        
		command "left"
		command "right"
		command "up"
		command "down"
        command "center"
        command "leftDown"
        command "leftUp"
        command "rightDown"
        command "rightUp"
        
		command "horizontalCruise"
		command "verticalCruise"
		command "stopCruise"
        
		command "preset1"
		command "preset2"
		command "preset3"
		command "preset4"
		command "preset5"
		command "preset6"
        command "presetTop"
        command "presetBottom"
        command "presetLeft"
        command "presetRight"
        
        command "reboot"
        command "checkMotionStatus"
        command "registerMotionCallback", ["string"]
        command "deRegisterMotionCallback"
        command "motionCallbackNotify"
        command "startVideo"
        command "setHiRes"
        command "setLowRes"
	}
    
    preferences {
        input title: "", description: "Foscam Device Handler v${clientVersion()}", displayDuringSetup: true, type: "paragraph", element: "paragraph"
        input title: "", description: "This IP is used for camera communication and video streaming. NOTE: If you're using a public IP/Hostname configure your routers to have port forwarding", displayDuringSetup: true, type: "paragraph", element: "paragraph"
        input("ip", "string", title:"Camera IP address/Public hostname", description: "Camera IP address or DNS hostname", required: true, displayDuringSetup: true)
        input("port", "number", title:"Camera port", description: "Camera port", defaultValue: "88" , required: false, displayDuringSetup: true) // required false for now due to bug in ST Android app requiring minimum 3 digits for a  number inputs for some tablets
        input("username", "string", title:"Camera Administrator username (case sensitive)", description: "Camera Administrative rights username (case sensitive)", required: true, displayDuringSetup: true)
        input("password", "password", title:"Camera password (case sensitive)", description: "Camera password (case sensitive)", required: false, displayDuringSetup: true)
        input("hdcamera", "bool", title:"Enable this if the camera is a HD model (720p or higher)?", description: "HD camera", required: false, displayDuringSetup: true)
        input("cameraModel", "enum", title:"Select your camera model", multiple: false, defaultValue: "Others", options: ["Others":"Other Foscam","Amba":"C2/R2/R2E/R4/FI9900P"], description: "Select Other Foscam if your camera model isn't listed here", required: true, displayDuringSetup: true)
        
        input title: "", description: "If your camera supports ONVIF in your Camera web settings -> Network page: enable it, set the RTSP port to 554 and enter it below to use RTSP live streaming", displayDuringSetup: true, type: "paragraph", element: "paragraph", required: true
        input("rtspport", "number", title:"RTSP port", description: "RTSP port", required: false, displayDuringSetup: true)
        input title: "", description: "(Optional) Use separate IP/hostname for video streaming. NOTE: If you're using a public IP/Hostname configure your routers to have port forwarding", displayDuringSetup: true, type: "paragraph", element: "paragraph"
        input("externalIp", "string", title:"Video Streaming IP address/hostname", description: "External IP address or DNS hostname", required: false, displayDuringSetup: true)

        // Use Camera Settings instead of forcing them here
        //input("mirror", "bool", title:"Mirror", description: "Mirror image? (Horizontal)?", required: false, displayDuringSetup: true)
        //input("flip", "bool", title:"Flip", description: "Flip image? (Vertical)?", required: false, displayDuringSetup: true)
        
        input title: "", description: "Configure the motion/sound detection features of the camera. NOTE: Sound detection is very sensitive on Foscam cameras", displayDuringSetup: true, type: "paragraph", element: "paragraph"
        input("motionLevel", "enum", title:"Motion detection sensitivity level", multiple: false, defaultValue: "Medium", options: ["Lowest","Lower","Low","Medium","High"], description: "Alarm Motion Sensitivity Level", required: true, displayDuringSetup: true)
        input("soundAlarm", "bool", title:"Enable sound detection", description: "Report audio events as motion events", defaultValue: false, required: false, displayDuringSetup: true)
        input("soundLevel", "enum", title:"Sound detection sensitivity level", multiple: false, defaultValue: "Lowest", options: ["Lowest","Lower","Low","Medium","High"], description: "Alarm Sound Sensitivity Level", required: true, displayDuringSetup: true)
        input title: "", description: "To use eMail notifications configure the eMail settings on your camera using the Foscam app/camera web settings", displayDuringSetup: true, type: "paragraph", element: "paragraph"
        input("motionEMail", "bool", title:"Intruder detected -> Send eMail", description: "Send e-Mail when motion is detected", defaultValue: true, required: false, displayDuringSetup: true)
        input("motionSnap", "bool", title:"Intruder detected -> Take picture (HD cameras only)", description: "Take a picture when motion is detected", defaultValue: true, required: false, displayDuringSetup: true)
        input("motionRecord", "bool", title:"Intruder detected -> Record video (HD cameras only)", description: "Record a video when motion is detected", defaultValue: true, required: false, displayDuringSetup: true)
        input("motionRing", "bool", title:"Intruder detected -> Turn on camera audio alarm (HD cameras only)", description: "Sound local ring alarm when motion is detected", defaultValue: true, required: false, displayDuringSetup: true)
        //input("reArmInterval", "enum", title:"Intruder detected -> Re-Arm interval (HD cameras only)", multiple: false, defaultValue: "15s", options: ["5s","6s","7s","8s","9s","10s","11s","12s","13s","14s","15s"], description: "Alarm Motion Snap Interval in seconds", required: true, displayDuringSetup: true)
        
        input title: "", description: "Configure the following 2 options only if your camera supports enabling/disabling Video motion and (Human) PIR motion detection separately", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("motionAlarmEnable", "bool", title:"Enable video motion detection", description: "Enable camera video motion detection", defaultValue: true, required: false, displayDuringSetup: false)
        input("pirAlarmEnable", "bool", title:"Enable PIR motion detection", description: "Enable human motion detection", defaultValue: true, required: false, displayDuringSetup: false)
        
        input title: "", description: "SmartTiles requires MJPEG streaming\nIf your HD camera supports MJPEG, enable this option to view the live stream in SmartTiles using this URL: http://IPADDRESS:PORT/cgi-bin/CGIStream.cgi?cmd=GetMJStream&usr=USERNAME&pwd=PASSWORD", displayDuringSetup: true, type: "paragraph", element: "paragraph"
        input("mjpeg", "bool", title:"Enable MJPEG (HD cameras only)", description: "MJPEG Streaming", required: false, displayDuringSetup: true)
        input("lightCompensation", "bool", title:"Compensate for sudden light changes (SD cameras only)", description: "Reduce motion alarms due to sudden changes in light", defaultValue: true, required: false, displayDuringSetup: false)
        //input("detectionArea", "string", title:"(Advanced) Enter the motion detection area parameters (leave empty if unsure)", description: "Enter the parameters to use for motion detection area without the leading or trailing &, leave blank for default full screen detection", required: false, displayDuringSetup: false)

        input title: "", description: "THESE SETTINGS ONLY APPLY TO THE NEW FOSCAM AMBARELLA CAMERAS (e.g. C2/R2/R2E/R4/FI9900P)", displayDuringSetup: false, type: "paragraph", element: "paragraph", required: true
        input("disableMotionDetect", "bool", title:"Disable motion detection", description: "Disable regular camera motion detection", defaultValue: false, required: false, displayDuringSetup: false)
        input("humanMotionDetect", "bool", title:"Enable human detection", description: "Detect human presence", defaultValue: false, required: false, displayDuringSetup: false)
        input("humanSensitivity", "number", title:"Human detection sensitivity", description: "Sensitivity for detecting humans", defaultValue: "100", range: "0..100", required: false, displayDuringSetup: false)
        input("humanCountEnable", "bool", title:"Enable people counting", description: "Count humans detected", defaultValue: false, required: false, displayDuringSetup: false)
        input("humanBoxingEnable", "bool", title:"Enable bounding box", description: "Detect human boundaries", defaultValue: false, required: false, displayDuringSetup: false)
        input("uploadCloud", "bool", title:"Intruder detected -> Upload to cloud", description: "Upload picture and recording to Foscam cloud", defaultValue: false, required: false, displayDuringSetup: false)
        input("pushFoscamPhoneApp", "bool", title:"Intruder detected -> Push message to Foscam app", description: "Push notification to Foscam native phone app", defaultValue: false, required: false, displayDuringSetup: false)
	}

	tiles(scale: 2) {
		multiAttributeTile(name:"summary", type: "generic", width: 6, height: 4){
			tileAttribute ("device.alarmStatus", key: "PRIMARY_CONTROL") {
              attributeState "off", label: "Detect Off", action: "toggleAlarm", icon: "st.camera.dlink-hdpan", backgroundColor: "#FFFFFF", nextState: "..."
              attributeState "on", label: "Detect On", action: "toggleAlarm", icon: "st.camera.dlink-hdpan",  backgroundColor: "#00a0dc", nextState: "..."
              attributeState "alarm", label: "Motion", action: "toggleAlarm", icon: "st.camera.dlink-hdpan",  backgroundColor: "#e86d13", nextState: "..."
              attributeState "error", label: "ERROR", action: "", icon: "st.camera.dlink-hdpan",  backgroundColor: "#FF3333"
              attributeState "...", label: "..."
            }
            tileAttribute ("device.ledStatus", key: "SECONDARY_CONTROL") {
                attributeState "autoOn", label: "Auto", action: "toggleLED", icon: "st.lights.multi-light-bulb-on", backgroundColor: "#79b821", nextState: "..."
                attributeState "autoOff", label: "Auto", action: "toggleLED", icon: "st.lights.multi-light-bulb-on", backgroundColor: "#9ceaf0", nextState: "..."
                attributeState "on", label: "On", action: "toggleLED", icon: "st.lights.multi-light-bulb-off", backgroundColor: "#79b821", nextState: "..."
                attributeState "off", label: "Off", action: "toggleLED", icon: "st.lights.multi-light-bulb-off", backgroundColor: "#FFFFFF", nextState: "..."
                attributeState "...", label: "..."
            }
        }
        
        multiAttributeTile(name: "videoPlayer", type: "videoPlayer", width: 6, height: 4) {
            tileAttribute("device.camera", key: "CAMERA_STATUS") {
				attributeState("on", label: "Active", icon: "st.camera.dlink-hdpan", action: "", backgroundColor: "#79b821", defaultState: true)
				attributeState("off", label: "Inactive", icon: "st.camera.dlink-hdpan", action: "", backgroundColor: "#ffffff")
				attributeState("restarting", label: "Connecting", icon: "st.camera.dlink-hdpan", backgroundColor: "#53a7c0")
				attributeState("unavailable", label: "Click here to connect", icon: "st.camera.dlink-hdpan", action: "", backgroundColor: "#F22000")
			}

			tileAttribute("device.errorMessage", key: "CAMERA_ERROR_MESSAGE") {
				attributeState("errorMessage", label: "", value: "", defaultState: true)
			}

			tileAttribute("device.camera", key: "PRIMARY_CONTROL") {
				attributeState("on", label: "Active", icon: "st.camera.dlink-hdpan", backgroundColor: "#79b821")
				attributeState("off", label: "Inactive", icon: "st.camera.dlink-hdpan", backgroundColor: "#ffffff", defaultState: true)
				attributeState("restarting", label: "Connecting", icon: "st.camera.dlink-hdpan", backgroundColor: "#53a7c0")
				attributeState("unavailable", label: "Click here to connect", icon: "st.camera.dlink-hdpan", backgroundColor: "#F22000")
			}

            tileAttribute ("device.ledStatus", key: "SECONDARY_CONTROL") {
                attributeState "autoOn", label: "Auto", action: "toggleLED", icon: "st.lights.multi-light-bulb-on", backgroundColor: "#79b821", nextState: "..."
                attributeState "autoOff", label: "Auto", action: "toggleLED", icon: "st.lights.multi-light-bulb-on", backgroundColor: "#9ceaf0", nextState: "..."
                attributeState "on", label: "On", action: "toggleLED", icon: "st.lights.multi-light-bulb-off", backgroundColor: "#79b821", nextState: "..."
                attributeState "off", label: "Off", action: "toggleLED", icon: "st.lights.multi-light-bulb-off", backgroundColor: "#FFFFFF", nextState: "..."
                attributeState "...", label: "..."
            }

            tileAttribute("device.startLive", key: "START_LIVE") {
				attributeState("live", action: "startVideo", defaultState: true)
			}

			tileAttribute("device.stream", key: "STREAM_URL") {
				attributeState("activeURL", defaultState: true)
			}

			/*tileAttribute("device.profile", key: "STREAM_QUALITY") {
				attributeState("hi", label: "Hi-Res", action: "setHiRes", defaultState: true)
				attributeState("low", label: "Low-Res", action: "setLowRes")
			}*/ // TODO: No profiles for now, lowRes MJPEG is not 100% stable so only use hiRes for now

			/*tileAttribute("device.betaLogo", key: "BETA_LOGO") {
				attributeState("betaLogo", label: "", value: "", defaultState: true)
			}*/
		}
		
        standardTile("alarmStatusA", "device.alarmStatus", width: 2, height: 2, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
            state "off", label: "Off", action: "toggleAlarm", icon: "st.camera.dlink-hdpan", backgroundColor: "#FFFFFF", nextState: "...", defaultState: true
            state "on", label: "On", action: "toggleAlarm", icon: "st.camera.dlink-hdpan",  backgroundColor: "#00a0dc", nextState: "..."
            state "alarm", label: "Motion", action: "toggleAlarm", icon: "st.camera.dlink-hdpan",  backgroundColor: "#e86d13", nextState: "..."
            state "error", label: "ERROR", action: "", icon: "st.camera.dlink-hdpan",  backgroundColor: "#FF3333"
            state "...", label: "..."
        }
        
        carouselTile("cameraDetails", "device.image", width: 4, height: 2) { }

		standardTile("take", "device.image", width: 2, height: 2, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: "Snap", action: "Image Capture.take", icon: "st.camera.camera", backgroundColor: "#FFFFFF", nextState: "taking", defaultState: true
			state "image", label: "Snap", action: "Image Capture.take", icon: "st.camera.camera", backgroundColor: "#FFFFFF", nextState: "taking"
			state "taking", label:'Taking', action: "", icon: "st.camera.take-photo", backgroundColor: "#53a7c0"
		}

        standardTile("ledStatus", "device.ledStatus", width: 2, height: 2, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
          state "autoOn", label: "Auto", action: "toggleLED", icon: "st.lights.multi-light-bulb-on", backgroundColor: "#79b821", nextState: "...", defaultState: true
          state "autoOff", label: "Auto", action: "toggleLED", icon: "st.lights.multi-light-bulb-on", backgroundColor: "#9ceaf0", nextState: "..."
          state "on", label: "On", action: "toggleLED", icon: "st.lights.multi-light-bulb-off", backgroundColor: "#79b821", nextState: "..."
          state "off", label: "Off", action: "toggleLED", icon: "st.lights.multi-light-bulb-off", backgroundColor: "#FFFFFF", nextState: "..."
          state "...", label: "..."
        }

		standardTile("preset1", "device.preset1", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: 'Preset ${currentValue}', action: "preset1", icon: "", defaultState: true
		}

		standardTile("preset2", "device.preset2", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: 'Preset ${currentValue}', action: "preset2", icon: "", defaultState: true
		}

		standardTile("preset3", "device.preset3", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: 'Preset ${currentValue}', action: "preset3", icon: "", defaultState: true
		}
        
		standardTile("preset4", "device.preset4", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: 'Preset ${currentValue}', action: "preset4", icon: "", defaultState: true
		}
        
		standardTile("preset5", "device.preset5", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: 'Preset ${currentValue}', action: "preset5", icon: "", defaultState: true
		}
        
		standardTile("preset6", "device.preset6", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: 'Preset ${currentValue}', action: "preset6", icon: "", defaultState: true
		}
        
		standardTile("presettop", "device.presetTop", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: '', action: "", icon: "", defaultState: true
			state "topmost", label: 'Top Most', action: "presetTop", icon: "", nextState: "topmost"
		}

		standardTile("presetbottom", "device.presetBottom", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: '', action: "", icon: "", defaultState: true
			state "bottommost", label: 'Bottom Most', action: "presetBottom", icon: "", nextState: "bottommost"
		}

		standardTile("presetleft", "device.presetLeft", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: '', action: "", icon: "", defaultState: true
			state "leftmost", label: 'Left Most', action: "presetLeft", icon: "", nextState: "leftmost"
		}

		standardTile("presetright", "device.presetRight", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: '', action: "", icon: "", defaultState: true
			state "rightmost", label: 'Right Most', action: "presetRight", icon: "", nextState: "rightmost"
		}

		standardTile("horizontalcruise", "device.horizontalcruise", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: 'Horizontal Cruise', action: "horizontalCruise", icon: "", defaultState: true
		}

		standardTile("verticalcruise", "device.verticalCruise", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: 'Vertical Cruise', action: "verticalCruise", icon: "", defaultState: true
		}
 
 		standardTile("stopcruise", "device.image", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: "Stop Cruise", action: "stopCruise", icon: "", defaultState: true
		}

		standardTile("leftUp", "device.image", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: "", action: "leftUp", icon: "http://smartthings.rboyapps.com/images/arrowTopLeft.png", defaultState: true
		}

		standardTile("leftDown", "device.image", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: "", action: "leftDown", icon: "http://smartthings.rboyapps.com/images/arrowBottomLeft.png", defaultState: true
		}

		standardTile("rightUp", "device.image", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: "", action: "rightUp", icon: "http://smartthings.rboyapps.com/images/arrowTopRight.png", defaultState: true
		}

		standardTile("rightDown", "device.image", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: "", action: "rightDown", icon: "http://smartthings.rboyapps.com/images/arrowBottomRight.png", defaultState: true
		}

		standardTile("left", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
			state "default", label: "", action: "left", icon: "http://smartthings.rboyapps.com/images/arrowLeft.png", defaultState: true
		}

		standardTile("right", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
			state "default", label: "", action: "right", icon: "http://smartthings.rboyapps.com/images/arrowRight.png", defaultState: true
		}

		standardTile("up", "device.image", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: "", action: "up", icon: "http://smartthings.rboyapps.com/images/arrowTop.png", defaultState: true
		}

		standardTile("down", "device.image", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: "", action: "down", icon: "http://smartthings.rboyapps.com/images/arrowBottom.png", defaultState: true
		}

		standardTile("center", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
			state "default", label: "Center", action: "center", icon: "", defaultState: true
		}

        standardTile("refresh", "device.status", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
        	state "default", action:"refresh.refresh", icon:"st.secondary.refresh", defaultState: true
        }
        
        standardTile("blank", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
        	state "default", label: "", action: "", icon: "", backgroundColor: "#FFFFFF", defaultState: true
        }
        
        standardTile("blank2x", "device.image", width: 2, height: 2, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
        	state "default", label: "", action: "", icon: "", backgroundColor: "#FFFFFF", defaultState: true
        }
        
        standardTile("reboot", "device.image", width: 1, height: 1, inactiveLabel: false, decoration: "flat") {
      		state "default", label: "reboot", action: "reboot", icon: "st.quirky.spotter.quirky-spotter-plugged", defaultState: true
    	}

        main "summary", "videoPlayer"
        details(["ledStatus", "refresh", "alarmStatusA", "cameraDetails", "take", "videoPlayer", "preset1", "preset2", "preset3", "preset4", "preset5", "preset6", "leftUp", "up", "rightUp", "horizontalcruise", "stopcruise", "verticalcruise", "left", "center", "right", "presetleft", "presettop", "presetright", "leftDown", "down", "rightDown", "blank", "presetbottom", "reboot"])
	}
}

import groovy.json.JsonSlurper
include 'asynchttp'

// Default milli-seconds delay between sending commands so the camera can respond
private getDelayInterval() { 200 }

def initialize() {
    log.trace "Initialize called settings: $settings"

    // Device-Watch simply pings if no device events received for checkInterval duration of 32min = 2 * 15min + 2min lag time
	sendEvent(name: "checkInterval", value: 2 * 15 * 60 + 2 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])

	try {
		if (!state.init) {
			state.init = true
		}
        response(refresh())
	} catch (e) {
		log.warn "initialize() threw $e"
	}
}

// TODO: For some users, BUG WITH SMARTTHINGS PLATFORM, EVERYTIME A SMARTAPP CALLS A DEVICE FUNCTION, THIS UPDATED FUNCTION IS ALSO CALLED!!! IT ALSO CAUSES RANDOM ISSUES LIKE EVENT STATE BEING LOST FOR SOME USERS
def updated() {
	log.trace "Update called settings: $settings"
	
    // Device-Watch simply pings if no device events received for checkInterval duration of 32min = 2 * 15min + 2min lag time
	sendEvent(name: "checkInterval", value: 2 * 15 * 60 + 2 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])

    try {
		if (!state.init) {
			state.init = true
		}
        response(refresh()) // Get the updates and configure the video streams
	} catch (e) {
		log.warn "updated() threw $e"
	}
}

def ping() {
	refresh()
}

//START VIDEO
// Thank you for the tip @ahndee
mappings {
    path("/getInHomeURL") {
        action:
            [GET: "getInHomeURL"]
    }
    
    path("/getOutHomeURL") {
        action:
            [GET: "getOutHomeURL"]
    }
}

def getInHomeURL() {
    log.trace "Called getInHomeURL, returning $state.uri"
    state.uri ? [InHomeURL: state.uri] : null // return null if it's not initialized otherwise ST app crashes
}

def getOutHomeURL() {
    log.trace "Called getOutHomeURL, returning $state.uriOut"
    state.uriOut ? [OutHomeURL: state.uriOut] : null // return null if it's not initialized otherwise ST app crashes
}

def setHiRes() {
    log.debug "Setting hi resolution stream"
    def cleanIP = ip.toLowerCase().replace("https://", "").replace("http://", "") // Sanitize the hostname/IP address, remove leading http(s)
    def cleanIPOut = (externalIp ?: ip).toLowerCase().replace("https://", "").replace("http://", "") // Sanitize the hostname/IP address, remove leading http(s)
    if (hdcamera) {
        log.debug "Enabling HiRes Stream type 0 for HD Camera"
        sendCmd("cmd=setMainVideoStreamType&streamType=0") // TODO: Should we always use stream 0?
        
        log.trace "Using h.264 main stream for high bitrate streaming"
        state.uri = "rtsp://${(username)}:${(password?:"")}@${cleanIP}:${rtspport ?: port}/videoMain" // http://foscam.us/forum/how-to-use-rtsp-and-https-for-hd-cameras-t4926.html
        state.uriOut = "rtsp://${(username)}:${(password?:"")}@${cleanIPOut}:${rtspport ?: port}/videoMain" // http://foscam.us/forum/how-to-use-rtsp-and-https-for-hd-cameras-t4926.html
    } else {
        log.trace "Setting up high resolution stream for SD camera" // Apple Audio can be set via videostream.asf, videostream.cgi only provides video with no audio
        state.uri = "http://${cleanIP}:${port}" + "/videostream.asf?" + "user=${username}&pwd=${password?:""}" + "&resolution=32" // High resolution (640x480) is 32, low is 8 (320x240), don't URL encode the password since it doesnt work here
        state.uriOut = "http://${cleanIPOut}:${port}" + "/videostream.asf?" + "user=${username}&pwd=${password?:""}" + "&resolution=32" // High resolution (640x480) is 32, low is 8 (320x240), don't URL encode the password since it doesnt work here
    }

    sendEvent(name: "profile", value: "hi", displayed: false)
}

private void setSubStreamingMode(mjpegEnable) {
    log.debug "Setting sub streaming mode for Camera (MJPEG mode enables SmartTiles compatibility) : ${mjpegEnable ? "MJPEG" : "h.264"}"
    sendCmd("cmd=setSubStreamFormat&format=" + (mjpegEnable ? "1" : "0")) // 1 for MJPEG, 0 for H.264 stream http://foscam.us/forum/how-to-fetch-snapshots-and-mjpeg-stream-on-hd-cameras-t4328.html
}

def setLowRes() {
    log.debug "Setting low resolution stream"
    def cleanIP = ip.toLowerCase().replace("https://", "").replace("http://", "") // Sanitize the hostname/IP address, remove leading http(s)
    def cleanIPOut = (externalIp ?: ip).toLowerCase().replace("https://", "").replace("http://", "") // Sanitize the hostname/IP address, remove leading http(s)
    if (hdcamera) { // The newer HD cameras can operate as MPEG or h.264
        setSubStreamingMode(mjpeg) // Configure h.264 or MJPEG for sub streaming video. MJPEG required for compatibility with SmartTiles
        
        if (mjpeg) {
            log.trace "Using MJPEG for low bitrate streaming"
            state.uri = "http://${cleanIP}:${port}" + "/cgi-bin/CGIStream.cgi?cmd=GetMJStream&" + "usr=${username}&pwd=${password?:""}" // Don't URL encode the password here since it doesn't seem to work for special characters like ! with this special Video Tile
            state.uriOut = "http://${cleanIPOut}:${port}" + "/cgi-bin/CGIStream.cgi?cmd=GetMJStream&" + "usr=${username}&pwd=${password?:""}" // Don't URL encode the password here since it doesn't seem to work for special characters like ! with this special Video Tile
        } else {
            log.trace "Using h.264 sub stream for low bitrate streaming"
            state.uri = "rtsp://${(username)}:${(password?:"")}@${cleanIP}:${rtspport ?: port}/videoSub" // http://foscam.us/forum/how-to-use-rtsp-and-https-for-hd-cameras-t4926.html
            state.uriOut = "rtsp://${(username)}:${(password?:"")}@${cleanIPOut}:${rtspport ?: port}/videoSub" // http://foscam.us/forum/how-to-use-rtsp-and-https-for-hd-cameras-t4926.html
        }
    } else { // Older SD cameras use MJPEG by default
        log.trace "Setting up low resolution stream for SD camera" // Apple Audio can be set via videostream.asf, videostream.cgi only provides video with no audio
        state.uri = "http://${cleanIP}:${port}" + "/videostream.asf?" + "user=${username}&pwd=${password?:""}" + "&resolution=8" // High resolution (640x480) is 32, low is 8 (320x240), don't URL encode the password since it doesnt work here
        state.uriOut = "http://${cleanIPOut}:${port}" + "/videostream.asf?" + "user=${username}&pwd=${password?:""}" + "&resolution=8" // High resolution (640x480) is 32, low is 8 (320x240), don't URL encode the password since it doesnt work here
    }

    sendEvent(name: "profile", value: "low", displayed: false)
}

def startVideo() {
    def hiRes = (device.currentValue("profile") == "low" ? false : true) // default to hi res (since low res has issue with mjpeg)
	log.debug "Starting video streaming with ${hiRes ? "High" : "Low"} profile stream"

    log.trace "Fetching video from:\nInHome: ${state.uri}\nOutHome: ${state.uriOut}"
    
    if (!state.uri || !state.uriOut) {
        refresh() // Initialize the camera
    }
    
	def dataLiveVideo = [
		InHomeURL   : state.uri, // TODO: Only this appears to be used
		OutHomeURL  : state.uriOut, // ?
		ThumbnailURL: "http://cdn.device-icons.smartthings.com/camera/dlink-hdpan@2x.png",
		cookie      : [key: "key", value: "value"]
	]

    log.trace "Video settings: $dataLiveVideo"
    
	def event = [
		name           : "stream",
		value          : groovy.json.JsonOutput.toJson(dataLiveVideo).toString(),
		data		   : groovy.json.JsonOutput.toJson(dataLiveVideo),
		descriptionText: "Starting the live video stream",
		eventType      : "VIDEO",
		displayed      : false,
		isStateChange  : true
	]
    
	sendEvent(event)
}
//END START VIDEO

//TAKE PICTURE
def take() {
	log.debug("Taking Photo")
    if (rateLimitExceeded()) {
        log.warn "Too many pictures taken in too short a time, skipping request"
        return
    }
	sendEvent(name: "hubactionMode", value: "s3", displayed: false)
    if(hdcamera) {
		sendCmd("cmd=snapPicture2")
    } else {
    	sendCmd("/snapshot.cgi?")
    }
}
//END TAKE PICTURE

//SWITCH ACTIONS
def on() {
	log.debug "On requested, enabling monitoring"
    alarmOn()
}

def off() {
	log.debug "Off requested, disabling monitoring"
    alarmOff()
}
//END SWITCH ACTIONS

//ALARM ACTIONS
def both() {
	log.debug "Alarm both requested, enabling monitoring and taking picture"
    take()
    alarmOn()
}

def siren() {
	log.debug "Alarm siren requested, enabling monitoring and taking picture"
    take()
    alarmOn()
}

def strobe() {
	log.debug "Alarm strobe requested, enabling monitoring and taking picture"
    take()
    alarmOn()
}

def toggleAlarm() {
	log.debug "Toggling Alarm"
	if(device.currentValue("alarmStatus") == "off") {
    	alarmOn()
  	} else {
    	alarmOff()
	}
}

def hdDetect(data) {
    if (data?.on) {
        log.trace "Turning on HD motion detection"

        if (cameraModel == "Amba") {
            sendCmds([("cmd=setMotionDetectConfig1&isEnable=${disableMotionDetect ? "0" : "1"}&isMovAlarmEnable=${motionAlarmEnable ? "1" : "0"}&isPirAlarmEnable=${pirAlarmEnable ? "1" : "0"}&snapInterval=1&linkage=${getAmbaMotionAlarmEvents()}&triggerInterval=${getReArmInterval("15s")}&${getDetectionArea()}&schedule0=281474976710655&schedule1=281474976710655&schedule2=281474976710655&schedule3=281474976710655&schedule4=281474976710655&schedule5=281474976710655&schedule6=281474976710655"), ("cmd=setHumanDetectConfig&isEnable=${humanMotionDetect ? "1" : "0"}&sensitivity=${humanSensitivity ?: "100"}&isHumanCountEnable=${humanCountEnable ? "1" : "0"}&isHumanBoxingEnable=${humanBoxingEnable ? "1" : "0"}&linkage=${getAmbaMotionAlarmEvents()}&snapInterval=1&triggerInterval=${getReArmInterval("10s")}&schedule0=281474976710655&schedule1=281474976710655&schedule2=281474976710655&schedule3=281474976710655&schedule4=281474976710655&schedule5=281474976710655&schedule6=281474976710655"), ("cmd=setAudioAlarmConfig&isEnable=${soundAlarm ? "1" : "0"}&sensitivity=${getSoundLevel(soundLevel)}&linkage=${getAmbaMotionAlarmEvents()}&triggerInterval=${getReArmInterval("15s")}&schedule0=281474976710655&schedule1=281474976710655&schedule2=281474976710655&schedule3=281474976710655&schedule4=281474976710655&schedule5=281474976710655&schedule6=281474976710655"), ("cmd=getDevState")])
        } else {
            sendCmds([("cmd=setMotionDetectConfig&isEnable=1&isMovAlarmEnable=${motionAlarmEnable ? "1" : "0"}&isPirAlarmEnable=${pirAlarmEnable ? "1" : "0"}&snapInterval=1&sensitivity=${getMotionLevel(motionLevel)}&linkage=${getMotionAlarmEvents()}&triggerInterval=${getReArmInterval("15s")}&schedule0=281474976710655&schedule1=281474976710655&schedule2=281474976710655&schedule3=281474976710655&schedule4=281474976710655&schedule5=281474976710655&schedule6=281474976710655&${getDetectionArea()}&1421696056773"), ("cmd=setAudioAlarmConfig&isEnable=${soundAlarm ? "1" : "0"}&sensitivity=${getSoundLevel(soundLevel)}&linkage=${getMotionAlarmEvents()}&triggerInterval=${getReArmInterval("15s")}&schedule0=281474976710655&schedule1=281474976710655&schedule2=281474976710655&schedule3=281474976710655&schedule4=281474976710655&schedule5=281474976710655&schedule6=281474976710655"), ("cmd=getDevState")])
        }
    } else if (data?.off) {        
        log.trace "Turning off HD motion detection"

        if (cameraModel == "Amba") {
            sendCmds([("cmd=setMotionDetectConfig1&isEnable=0&${getDetectionArea()}"), ("cmd=setHumanDetectConfig&isEnable=0"), ("cmd=setAudioAlarmConfig&isEnable=0"), status]) // Get a full status update after turning off
        } else {
            sendCmds([("cmd=setMotionDetectConfig&isEnable=0&${getDetectionArea()}"), ("cmd=setAudioAlarmConfig&isEnable=0"), status]) // Get a full status update after turning off
        }
    } else {
        log.warn "Unknown detection command: $data"
    }
}

def alarmOn() {
	log.debug "Enabling Motion Detection"

	if(hdcamera) {
        // Get the latest motion detection area settings before activating motion detection
        if (cameraModel == "Amba") {
            sendCmd("cmd=getMotionDetectConfig1")
        } else {
            sendCmd("cmd=getMotionDetectConfig")
        }
        runIn(1, hdDetect, [data: [on: true], overwrite: true]) // Turn on motion detection after giving the camera time to respond with the latest motion detection settings, only one active action at a time
    } else {
    	sendCmds([("/set_alarm.cgi?motion_armed=1&motion_sensitivity=${getMotionLevel(motionLevel)}&motion_compensation=${lightCompensation ? "1" : "0"}&sounddetect_armed=${soundAlarm ? "1" : "0"}&sounddetect_sensitivity=${getSoundLevel(soundLevel)}&mail=${motionEMail ? "1" : "0"}&"), ("/get_status.cgi?"), ("/get_params.cgi?")])
    }
}

def alarmOff() {
	log.debug "Disabling Alarm"

    if(hdcamera) {
        // Get the latest motion detection area settings before deactivating motion detection if user changed them while it was being used
        if (cameraModel == "Amba") {
            sendCmd("cmd=getMotionDetectConfig1")
        } else {
            sendCmd("cmd=getMotionDetectConfig")
        }
        runIn(1, hdDetect, [data: [off: true], overwrite: true]) // Turn it off offline so it cancels any pending actions
    } else {
    	sendCmds([("/set_alarm.cgi?motion_armed=0&sounddetect_armed=0&"), status]) // Get a full status update after turning off
    }
    
}
//END ALARM ACTIONS

//LED ACTIONS
//Toggle LED's
def toggleLED() {
	log.debug("Toggle LED")
    if(hdcamera) {
        if((device.currentValue("ledStatus") == "autoOn") || (device.currentValue("ledStatus") == "autoOff")) {
            ledOn()
        } else if(device.currentValue("ledStatus") == "on") {
            ledOff()
        } else {
            ledAuto()
        }
    } else {
        ledAuto() // There is no way to get current status of LED for SD Cameras to keep it in Auto all the time
    }
}

def ledOn() {
    log.debug("LED changed to: on")
    if(hdcamera) {
	    sendCmds([("cmd=setInfraLedConfig&mode=1"), ("cmd=openInfraLed"), status]) // Give it time to finish up before updating the UI
    } else {
        // The API does not provide a way to poll for LED status on 8xxx series at the moment, just keep it in autoOff mode
        sendEvent(name: "ledStatus", value: "autoOff", isStateChange: true, displayed: false) // Force state change required since it's invoked from action to udpate tile from ...
    	sendCmd("/decoder_control.cgi?command=95&")
    }
}

def ledOff() {
    log.debug("LED changed to: off")
    if(hdcamera) {
    	sendCmds([("cmd=setInfraLedConfig&mode=1"), ("cmd=closeInfraLed"), status]) // Update UI
    } else {
        // The API does not provide a way to poll for LED status on 8xxx series at the moment, just keep it in off mode
        sendEvent(name: "ledStatus", value: "off", isStateChange: true, displayed: false) // Force state change required since it's invoked from action to udpate tile from ...
    	sendCmd("/decoder_control.cgi?command=94&")
    }
}

def ledAuto() {
    log.debug("LED changed to: auto")
	if(hdcamera) {
		sendCmds([("cmd=setInfraLedConfig&mode=0"), status]) // Give auto time to calibrate and then Update UI
    } else {
        // The API does not provide a way to poll for LED status on 8xxx series at the moment, just keep it in autoOff mode
        sendEvent(name: "ledStatus", value: "autoOff", isStateChange: true, displayed: false) // Force state change required since it's invoked from action to udpate tile from ...
    	sendCmd("/decoder_control.cgi?command=95&")
    }
}
//END LED ACTIONS

//PRESET ACTIONS
def presetTop() {
	log.debug("Preset TopMost Selected")
	if(hdcamera) {
		sendCmd("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode("TopMost")}")
    } else {
    	log.warn "Not supported for SD cameras"
    }
}

def presetBottom() {
	log.debug("Preset BottomMost Selected")
	if(hdcamera) {
		sendCmd("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode("BottomMost")}")
    } else {
    	log.warn "Not supported for SD cameras"
    }
}

def presetRight() {
	log.debug("Preset RightMost Selected")
	if(hdcamera) {
		sendCmd("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode("RightMost")}")
    } else {
    	log.warn "Not supported for SD cameras"
    }
}

def presetLeft() {
	log.debug("Preset LeftMost Selected")
	if(hdcamera) {
		sendCmd("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode("LeftMost")}")
    } else {
    	log.warn "Not supported for SD cameras"
    }
}

def preset1() {
	log.debug("Preset 1 Selected - ${device.currentValue("preset1")}")
	if(hdcamera) {
		sendCmds([("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode(device.currentValue("preset1"))}"), status]) // Update UI
    } else {
    	sendCmds([("/decoder_control.cgi?command=31&"), status]) // Update UI
    }
}

def preset2() {
	log.debug("Preset 2 Selected - ${device.currentValue("preset2")}")
	if(hdcamera) {
		sendCmds([("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode(device.currentValue("preset2"))}"), status]) // Update UI
    } else {
    	sendCmds([("/decoder_control.cgi?command=33&"), status]) // Update UI
    }
}

def preset3() {
	log.debug("Preset 3 Selected - ${device.currentValue("preset3")}")
	if(hdcamera) {
		sendCmds([("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode(device.currentValue("preset3"))}"), status]) // Update UI
    } else {
    	sendCmds([("/decoder_control.cgi?command=35&"), status]) // Update UI
    }
}

def preset4() {
	log.debug("Preset 4 Selected - ${device.currentValue("preset4")}")
	if(hdcamera) {
		sendCmds([("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode(device.currentValue("preset4"))}"), status]) // Update UI
    } else {
    	sendCmds([("/decoder_control.cgi?command=37&"), status]) // Update UI
    }
}

def preset5() {
	log.debug("Preset 5 Selected - ${device.currentValue("preset5")}")
	if(hdcamera) {
		sendCmds([("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode(device.currentValue("preset5"))}"), status]) // Update UI
    } else {
    	sendCmds([("/decoder_control.cgi?command=39&"), status]) // Update UI
    }
}

def preset6() {
	log.debug("Preset 6 Selected - ${device.currentValue("preset6")}")
	if(hdcamera) {
		sendCmds([("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode(device.currentValue("preset6"))}"), status]) // Update UI
    } else {
    	sendCmds([("/decoder_control.cgi?command=41&"), status]) // Update UI
    }
}
//END PRESET ACTIONS

//CRUISE ACTIONS
def horizontalCruise() {
	log.debug("Horizontal Cruise Selected")
	if(hdcamera) {
		sendCmd("cmd=ptzStartCruise&mapName=Horizontal")
    } else {
    	sendCmd("/decoder_control.cgi?command=28&")
    }
}

def verticalCruise() {
	log.debug("Vertical Cruise Selected")
	if(hdcamera) {
		sendCmd("cmd=ptzStartCruise&mapName=Vertical")
    } else {
    	sendCmd("/decoder_control.cgi?command=26&")
    }
}

def stopCruise() {
	log.debug("Stop Cruise")
	if(hdcamera) {
		sendCmd("cmd=ptzStopRun")
    } else {
    	sendCmds([("/decoder_control.cgi?command=29&"), ("/decoder_control.cgi?command=27&")])
    }
}
//END CRUISE ACTIONS

//PTZ CONTROLS
private getSDPTZ() {
    [
        "LEFT_DOWN":93,
        "LEFT_UP":91,
        "RIGHT_DOWN":92,
        "RIGHT_UP":90,
        "LEFT":6,
        "RIGHT":4,
        "UP":0,
        "DOWN":2,
        "CENTER":25,
        "STOP":1,
    ]
}

def center() {
	if(hdcamera) {
        sendCmd("cmd=ptzReset")
    } else {
        sendCmd("/decoder_control.cgi?command=${SDPTZ.CENTER}&")
    }
}

def leftDown() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        sendCmds([("cmd=ptzMoveBottomLeft"), ("cmd=ptzStopRun")], 500)
    } else {
    	if(device.currentValue("mirrorStatus") && device.currentValue("flipStatus")) {
            sendCmds([("/decoder_control.cgi?command=${SDPTZ.RIGHT_UP}&"), ("/decoder_control.cgi?command=1&")], 500)
    	} else if(device.currentValue("mirrorStatus") && !device.currentValue("flipStatus")) {
            sendCmds([("/decoder_control.cgi?command=${SDPTZ.RIGHT_DOWN}&"), ("/decoder_control.cgi?command=1&")], 500)
    	} else if(!device.currentValue("mirrorStatus") && device.currentValue("flipStatus")) {
            sendCmds([("/decoder_control.cgi?command=${SDPTZ.LEFT_UP}&"), ("/decoder_control.cgi?command=1&")], 500)
        } else {
            sendCmds([("/decoder_control.cgi?command=${SDPTZ.LEFT_DOWN}&"), ("/decoder_control.cgi?command=1&")], 500)
        }
    }
}

def leftUp() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        sendCmds([("cmd=ptzMoveTopLeft"), ("cmd=ptzStopRun")], 500)
    } else {
    	if(device.currentValue("mirrorStatus") && device.currentValue("flipStatus")) {
            sendCmds([("/decoder_control.cgi?command=${SDPTZ.RIGHT_DOWN}&"), ("/decoder_control.cgi?command=1&")], 500)
    	} else if(device.currentValue("mirrorStatus") && !device.currentValue("flipStatus")) {
            sendCmds([("/decoder_control.cgi?command=${SDPTZ.RIGHT_UP}&"), ("/decoder_control.cgi?command=1&")], 500)
    	} else if(!device.currentValue("mirrorStatus") && device.currentValue("flipStatus")) {
            sendCmds([("/decoder_control.cgi?command=${SDPTZ.LEFT_DOWN}&"), ("/decoder_control.cgi?command=1&")], 500)
        } else {
            sendCmds([("/decoder_control.cgi?command=${SDPTZ.LEFT_UP}&"), ("/decoder_control.cgi?command=1&")], 500)
        }
    }
}

def left() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        sendCmds([("cmd=ptzMoveLeft"), ("cmd=ptzStopRun")], 1000)
    } else {
    	if(device.currentValue("mirrorStatus")) {
	    	sendCmd("/decoder_control.cgi?command=${SDPTZ.RIGHT}&onestep=1&")
        } else {
        	sendCmd("/decoder_control.cgi?command=${SDPTZ.LEFT}&onestep=1&")
        }
    }
}

def rightDown() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        sendCmds([("cmd=ptzMoveBottomRight"), ("cmd=ptzStopRun")], 500)
    } else {
    	if(device.currentValue("mirrorStatus") && device.currentValue("flipStatus")) {
            sendCmds([("/decoder_control.cgi?command=${SDPTZ.LEFT_UP}&"), ("/decoder_control.cgi?command=1&")], 500)
    	} else if(device.currentValue("mirrorStatus") && !device.currentValue("flipStatus")) {
            sendCmds([("/decoder_control.cgi?command=${SDPTZ.LEFT_DOWN}&"), ("/decoder_control.cgi?command=1&")], 500)
    	} else if(!device.currentValue("mirrorStatus") && device.currentValue("flipStatus")) {
            sendCmds([("/decoder_control.cgi?command=${SDPTZ.RIGHT_UP}&"), ("/decoder_control.cgi?command=1&")], 500)
        } else {
            sendCmds([("/decoder_control.cgi?command=${SDPTZ.RIGHT_DOWN}&"), ("/decoder_control.cgi?command=1&")], 500)
        }
    }
}

def rightUp() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        sendCmds([("cmd=ptzMoveTopRight"), ("cmd=ptzStopRun")], 500)
    } else {
    	if(device.currentValue("mirrorStatus") && device.currentValue("flipStatus")) {
            sendCmds([("/decoder_control.cgi?command=${SDPTZ.LEFT_DOWN}&"), ("/decoder_control.cgi?command=1&")], 500)
    	} else if(device.currentValue("mirrorStatus") && !device.currentValue("flipStatus")) {
            sendCmds([("/decoder_control.cgi?command=${SDPTZ.LEFT_UP}&"), ("/decoder_control.cgi?command=1&")], 500)
    	} else if(!device.currentValue("mirrorStatus") && device.currentValue("flipStatus")) {
            sendCmds([("/decoder_control.cgi?command=${SDPTZ.RIGHT_DOWN}&"), ("/decoder_control.cgi?command=1&")], 500)
        } else {
            sendCmds([("/decoder_control.cgi?command=${SDPTZ.RIGHT_UP}&"), ("/decoder_control.cgi?command=1&")], 500)
        }
    }
}

def right() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        sendCmds([("cmd=ptzMoveRight"), ("cmd=ptzStopRun")], 1000)
    } else {
    	if(device.currentValue("mirrorStatus")) {
	    	sendCmd("/decoder_control.cgi?command=${SDPTZ.LEFT}&onestep=1&")
        } else {
        	sendCmd("/decoder_control.cgi?command=${SDPTZ.RIGHT}&onestep=1&")
        }
    }
}

def up() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        sendCmds([("cmd=ptzMoveUp"), ("cmd=ptzStopRun")], 300)
    } else {
    	if(device.currentValue("flipStatus")) {
	    	sendCmd("/decoder_control.cgi?command=${SDPTZ.DOWN}&onestep=1&")
        } else {
        	sendCmd("/decoder_control.cgi?command=${SDPTZ.UP}&onestep=1&")
        }
    }
}

def down() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        sendCmds([("cmd=ptzMoveDown"), ("cmd=ptzStopRun")], 300)
    } else {
    	if(device.currentValue("flipStatus")) {
    		sendCmd("/decoder_control.cgi?command=${SDPTZ.UP}&onestep=1&")
        } else {
        	sendCmd("/decoder_control.cgi?command=${SDPTZ.DOWN}&onestep=1&")
        }
    }
}
//END PTZ CONTROLS

//REBOOT
def reboot() {
	log.debug "Rebooting camera"
	if(hdcamera) {
		sendCmd("cmd=rebootSystem")
    } else {
    	sendCmd("/reboot.cgi?&" + getLogin())
    }
}
//END REBOOT

// FOSCAM MANAGER INTERFACES
def checkMotionStatus() {
	log.debug "Checking motion alarm status"

	//Poll Motion Alarm Status
    if (hdcamera) {
        sendCmd("cmd=getDevState") // Motion/Alarm status
    } else {
    	sendCmds([("/get_status.cgi?"), ("/get_params.cgi?")]) // Motion Detection Status, Alarm Status
    }
}

def registerMotionCallback(callbackURL) {
	if (device.currentValue("alarmNotifyType") == "Pull") {
    	log.error "This cameras doesn't support callback URL, this should not be called"
    } else {
		log.debug "Registering motion detection callback URL -> $callbackURL"
        sendCmds([("/set_alarm.cgi?http=1&http_url=$callbackURL&"), status])
    }
}

def deRegisterMotionCallback() {
	if (device.currentValue("alarmNotifyType") == "Pull") {
    	log.error "This camera doesn't support deregistering callback URL, this should not be called"
    } else {
		log.debug "DeRegistering motion detection callback"
        sendCmds([("/set_alarm.cgi?http=0&"), status])
    }
}

def motionCallbackNotify() {
    log.info("Callback Notify: Motion Alarm Alert!!")
    sendEvent(name: "alarmStatus", value: "alarm")
    sendEvent(name: "alarm", value: "both")
    sendEvent(name: "switch", value: "on")
    sendEvent(name: "motion", value: "active", descriptionText: "$device.displayName detected motion")
    runIn(10, poll) // Polling will set the mode back to on or off (current mode), wait 10 seconds before turning off the alarm
}
//END FOSCAM MANAGER INTERFACES

def configure() {
    log.trace "Configuration called"
    
    def hiRes = (device.currentValue("profile") == "low" ? false : true) // default fall back hi resolution since low resolution has issues with mjpeg and ST app compatibility
	log.debug "Configuring video streaming for ${hiRes ? "High" : "Low"} Resolution stream"

    if (mjpeg && hdcamera) {
        log.debug "Enabling Camera MJPEG sub streaming mode for SmartTile compatibility"
        setSubStreamingMode(mjpeg)
    }
    
    if (hiRes) {
        setHiRes()
    } else {
        setLowRes()
    }
}

def refresh() {
	log.trace "Refresh called -> $settings"
    state.cameraHost = null // Reset it to force a lookup

    rateLimitExceeded("", true) // Reset rate allowance

    configure() // Configure the camera
	sendCmds(status, delayInterval)
}

def poll() {
	log.trace "Poll called -> $settings"
    sendCmds(status, delayInterval)
}

// Get a list of commands to get latest camera status
private getStatus() {
    //Update the tiles names
    if(!hdcamera) // SD cameras has standard preset names
    {
        (1..6).each {
            sendEvent(name: "preset${it}", value: "${it}", displayed: false)
        }
    }
    sendEvent(name: "cameraType", value: "${hdcamera ? "HD" : "SD"}", displayed: false)
    sendEvent(name: "alarmNotifyType", value: "${hdcamera ? "Pull" : "Push"}", displayed: false) // Only SD camera support Push notifications

    def cmds = [] // Put them all together in the right order

	//Poll Motion Alarm Status and IR LED Mode and device status
    if (hdcamera) {
        // Get the device, LED and Mirror status first
        cmds << ("cmd=getDevState") // Motion detection/alarm status
        cmds << ("cmd=getInfraLedConfig")
        cmds << ("cmd=getMirrorAndFlipSetting")
        cmds << ("cmd=getPTZPresetPointList") // Get list of preset points
        //cmds << ("cmd=getAudioAlarmConfig") // not required for now
        cmds << ("cmd=getMotionDetectConfig${cameraModel == "Amba" ? "1" : ""}") // Get any user configured settings for area from web interface
        //if (cameraModel == "Amba") {
        	//cmds << ("cmd=getHumanDetectConfig") // not required for now, we have everything we need
        //}

		/*// Enable/Disable Mirror - Use camera settings
        if (mirror && (device.currentValue("mirrorStatus") != 1)) {
            log.debug "Enabling video mirroring"
            cmds << ("cmd=mirrorVideo&isMirror=1")
            cmds << ("cmd=getMirrorAndFlipSetting")
        } else if (!mirror && (device.currentValue("mirrorStatus") != 0)) {
            log.debug "Disabling video mirroring"
            cmds << ("cmd=mirrorVideo&isMirror=0")
            cmds << ("cmd=getMirrorAndFlipSetting")
        }

		// Enable/Disable Flip
        if (flip && (device.currentValue("flipStatus") != 1)) {
            log.debug "Enabling video flipping"
            cmds << ("cmd=flipVideo&isFlip=1")
            cmds << ("cmd=getMirrorAndFlipSetting")
        } else if (!flip && (device.currentValue("flipStatus") != 0)) {
            log.debug "Disabling video flipping"
            cmds << ("cmd=flipVideo&isFlip=0")
            cmds << ("cmd=getMirrorAndFlipSetting")
        }*/
	} else { // SD Camera
        // Get all the settings first
        cmds << ("/get_status.cgi?") // Motion Detection Status
        cmds << ("/get_params.cgi?") // Alarm Status
    	cmds << ("/get_camera_params.cgi?") // Mirror and flip status

		/*// Enable/Disable Mirror - Use camera settings
        def setMirrorFlip = false
        if (mirror && (device.currentValue("mirrorStatus") != 1)) {
            log.debug "Enabling video mirroring"
            setMirrorFlip = true
        } else if (!mirror && (device.currentValue("mirrorStatus") != 0)) {
            log.debug "Disabling video mirroring"
            setMirrorFlip = true
        }

		// Enable/Disable Flip
        if (flip && (device.currentValue("flipStatus") != 1)) {
            log.debug "Enabling video flipping"
            setMirrorFlip = true
        } else if (!flip && (device.currentValue("flipStatus") != 0)) {
            log.debug "Disabling video flipping"
            setMirrorFlip = true
        }

		if (setMirrorFlip) {
            def value = 0
            if (mirror) {
                value |= 2
            }
            if (flip) {
                value |= 1
            }
            cmds << ("/camera_control.cgi?param=5&value=${value}&")
			cmds << ("/get_camera_params.cgi?")
        }*/
    }

    //log.trace "Returning -> ${cmds.inspect()}"
    cmds
}

private getLogin() {
	if(hdcamera) {
    	return "usr=${URLEncoder.encode(username)}&pwd=${URLEncoder.encode(password?:"")}&"
    }
    else {
    	return "user=${URLEncoder.encode(username)}&pwd=${URLEncoder.encode(password?:"")}"
    }
}

// Send single command to camera
private sendCmd(cmd) {
    sendCmds([cmd], 0)
}

// Send commands to the camera with an optional delay
// Commands can be Strings or Integers which indicate an explicit delay to be inserted there
private sendCmds(cmds, delay = delayInterval) {
    // Send the events here and not in hubresponse since it causes the video stream to be interrupted
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Foscam Device Handler"]) // Save DH Name for parent app

    def useIP // We can't use state.ipAddress since it will be updated here and state variables won't be committed until the function exits (so readback will not show the latest state)
    def cleanIP = ip.toLowerCase().replace("https://", "").replace("http://", "") // Sanitize the hostname/IP address, remove leading http(s)
    
    // ST has blocked access to Google DNS do don't convert hostname to IP for now, if we have a hostname/public IP use the server API else use local hubAction for local IP (also not all routers support loopback so prefer to use server when using a hostname or public ip)
    useIP = cleanIP
    
	/*// Check if we have a hostname and if so convert to IP Address
    //log.trace "Saved IP: $state.ipAddress, Saved Host: $state.cameraHost, User IP: $cleanIP"
    if (!state.ipAddress || (state.cameraHost != cleanIP)) { // check if the IP/Host has changed or we don't have an IP address
        if (!isIPAddress(cleanIP)) {
            //log.trace "Converting hostname $cleanIP to IP Address before continuing"
            def h2ip = convertHostnameToIPAddress(cleanIP)
            state.ipAddress = useIP = h2ip
            log.trace "Got IPAddress=${h2ip} for hostname=$cleanIP"
        } else {
            state.ipAddress = useIP = cleanIP
            log.trace "Using IPAddress=${cleanIP}"
        }
        state.cameraHost = cleanIP // We've completed the above successfully, cache it to improve performance
    } else {
        log.trace "Using cached IPAddress=${state.ipAddress}"
        useIP = state.ipAddress
    }
    
    if (!useIP) {
        log.error "ERROR: Unable to get usable IP address!!"
        return
    }*/
    
	// Setting Network Device Id (required if we are not using hubAction callback and also for Foscam Camera Manager)
    //log.trace "Using address: $useIP"
    if (isIPAddress(useIP)) {
        def iphex = convertIPtoHex(useIP)
        def porthex = convertPortToHex(port)
        if (device.deviceNetworkId != "$iphex:$porthex") { // We keep this up to date because the Foscam Camera Manager uses discovery to find new cameras based on LAN IP address and Port (dni)
            device.deviceNetworkId = "$iphex:$porthex"
            log.info "Device Network Id updated to ${iphex}:${porthex}"
        }
    } else {
        if (device.deviceNetworkId != "$useIP:$port") { // We keep this up to date because the Foscam Camera Manager uses discovery to find new cameras based on LAN IP address and Port (dni)
            device.deviceNetworkId = "$useIP:$port" // We need a unique DNI for any device so use the hostname and port combination for now (you can have multiple cameras on a host)
            log.info "Device Network Id updated to ${useIP}:${port}"
        }
    }

    def isIP = isIPAddress(useIP)
    def isPublicIP = isPublicIPAddress(useIP)
    def hubActions = []
    def logActions = []
    cmds?.flatten()?.each { cmd -> // If we have nested lists, flatten them out
        if (!((cmd as String)?.trim())) { // We get empty commands due to a loopback ignore them
            log.warn "Ignoring empty command"
            return
        }
        
        def uri = ""
        if (hdcamera) {
            uri = "/cgi-bin/CGIProxy.fcgi?" + getLogin() + cmd
        }
        else {
            uri = cmd + getLogin()
        }

        boolean doHubAction = false
        if (!isIP || isPublicIP) { // If we are working with hostname or a public IP address then use httpGet from ST cloud to public IP, it's faster and more reliable (doesn't depend on loopback)
            try {
                if (cmd instanceof Integer) { // Check if we're asked to delay the command
                    delayMs(cmd)
                    return // Move onto the next one
                }
                // Prefer Async as it doesn't block and timeout incase of an offline camera or bad IP
                if (device.currentValue("hubactionMode") == "s3") { // NOTE: Async is currently broken for JPEG images since it converts the response from the camera into a UTF-8 string which replaces non printable characters with EF BF BD (replacement character), so use sync for now
                    // Sync blocking httpGet
                    logActions << "Sending httpGet command -> http://${getHostAddress(cleanIP)}$uri"
                    sendEvent(name: "hubactionMode", value: "local", displayed: false)
                    httpGet("http://${getHostAddress(cleanIP)}$uri") { response -> parseHttpGetResponse(response) }
                    delayMs(delay) // Delay if we need
                } else {
                    // Async non blocking httpGet
                    logActions << "Sending Async httpGet command -> http://${getHostAddress(cleanIP)}$uri"
                    asynchttp.get(parseHttpGetAsyncResponse, [ uri: "http://${getHostAddress(cleanIP)}$uri" ])
                    delayMs(delay) // Delay if we need
                }
            } catch (Exception e) {
                log.error "Unable to send to host ${getHostAddress(cleanIP)}, Error: $e"
                if (isIP) { // Fallback only if it is an IP address
                    log.debug "Falling back to hubAction and retrying command"
                    doHubAction = true // lets fall back and retry, hubAction works for both private and public ip addresses
                }
            }
        } else { // If we are using local IP Address, use hubAction, the only way to communicate from hub to Camera.
            doHubAction = true
        }

        if (doHubAction) {
            if (cmd instanceof Integer) { // Check if we're asked to delay the command
                hubActions << new physicalgraph.device.HubAction("delay ${cmd}")
                return // Move onto the next one
            }
            logActions << "Sending hubAction command -> http://${getHostAddress(useIP)}$uri"
            def hubAction = new physicalgraph.device.HubAction(
                method: "GET",
                path: uri,
                headers: [HOST:getHostAddress(useIP)],
                String dni = null, // Remove this when using device.deviceNetworkId
                [callback: callbackParse], // Remove this when using device.deviceNetworkId
            )

            // If we have a picture then extract it and store it and set the hubAction mode accordingly
            if (device.currentValue("hubactionMode") == "s3") {
                log.trace "Resetting hubActionMode to local"
                hubAction.options = [outputMsgToS3:true, callback: callbackParse] // Remove callback when using device.deviceNetworkId
                sendEvent(name: "hubactionMode", value: "local", displayed: false)
            }

            hubActions << hubAction
        }
    }
    
    if (hubActions) { // If we have any hub actions queued, send them with the appropriate delay
        sendHubCommand(hubActions, delay)
    }
    
    log.trace("\n" + logActions?.join("\n"))
    
    null // Always return null so that if do don't get stuck in a loop accidentally
}

void callbackParse(physicalgraph.device.HubResponse hubResponse) {
    log.trace "Received callback response from Camera"
    //log.debug "Response: ${hubResponse}\nDescription: ${hubResponse.description}\nBody: ${hubResponse.body}"
    
    if (hubResponse.description) {
    	parseResponse(hubResponse.description)
    } else {
        log.error "Received an invalid response from Camera or hub"
    }
}

def parseHttpGetAsyncResponse(response, data) {
    if (response.hasError()) {
        log.warn "Aysnc httpGet response has error: ${response.getErrorMessage()}"
    }
    log.trace "Received response from camera to async httpGet, headers=${response.headers}, status=${response.status}, warning=${response.warningMessages}, data=$data"
    parseHttpGetResponse(response)
}
    
def parseHttpGetResponse(response) {
    log.trace "Received response from camera to httpGet, headers=${(response.headers?.'Content-type' ?: response.headers?.'Content-Type')}, status=${response.status}" // TODO: Bug with ST Async httpGet, https://community.smartthings.com/t/asynchronous-http-beta-feedback-thread/60280/11?
    if (response.status == 200) {
        if((!response.headers && response.data) || (response.headers?.'Content-type' ?: response.headers?.'Content-Type')?.contains("image/jpeg")) { // If we have a picture store it directly (TODO: Bug with Async httpGet, the header is null for image data)
            if(response.data) {
                /*def sb = "" // Dump the first 50 bytes for debugging
                if (response.data instanceof String) {
                    response.data.take(50).getBytes().each { sb += String.format("%02X", (it & 0xff)) + " " }
                } else {
                    (0..50).each {
                        sb += String.format("%02X", (response.data.buf[it] & 0xff)) + " " // convert each byte to hex without converting to a string since it loses non printable data
                    }
                }
                log.warn sb*/

                def image = (response.data instanceof String) ? new ByteArrayInputStream(response.data.getBytes("US-ASCII")) : response.data // httpGet async returns String data where as httpGet synchronous returns a byte array input stream
                
                // Send the image to an App who wants to consume it via an event as a Base64 String - NOTE: Disabled for now since ST has put a limitation on this which is causing trouble with the carousel
                //def bytes = image.buf
                //log.debug "JPEG Data Size: ${bytes.size()}"
                //String str = bytes.encodeBase64()
                //sendEvent(name: "imageDataJpeg", value: str, displayed: false, isStateChange: true)
                //sendEvent(name: "imageDataJpeg", value: "", displayed: false, isStateChange: false) // Wipe it clean so it empties any old data

                // Now save it to the S3 cloud, so this in the end since it removes the data from the object leaving it empty
                log.info "Saving picture to SmartThings"
                storeImage(getPictureName(), image)
            } else {
                log.warn "Received an empty response from camera, expecting a JPEG image"
            }
        } else if((response.headers?.'Content-type' ?: response.headers?.'Content-Type')?.contains("text/plain")) { // Otherwise process the camera response codes
            String body
            if (response.data instanceof java.io.StringReader) { // httpGet
                body = response.data.getText()
            } else { // httpGet Async
                body = response.data
            }
            //log.trace "httpGet -> ${body}"
            processResponse(body)
        } else {
            log.error "Unknown response from camera, no header"
        }
    } else {
        log.error "Error response from host ${getHostAddress(ip)}, HTTP Response code: $response.status"
    }
}

// This function is called when we are using hubAction with a networkDeviceId (not callback)
def parse(String description) {
	log.trace "Received response from Camera to hubAction"
    parseResponse(description)
}

private parseResponse(description){     
    def descMap = parseDescriptionAsMap(description)
    //log.trace "${descMap.inspect()}"
    
    // Check if its a picture and process it
	if (descMap["tempImageKey"]) {
		putImageInS3(descMap)
	} else if (descMap["headers"] && descMap["body"]) { // Otherwise check camera response
        def body = new String(descMap["body"].decodeBase64())
	    //log.trace "Body -> ${body}"
		processResponse(body)
	}
}

def parseDescriptionAsMap(description) {
	description.split(",").inject([:]) { map, param ->
		def nameAndValue = param.split(":")
		map += [(nameAndValue[0].trim()):nameAndValue[1].trim()]
	}
}

def putImageInS3(map) {
    //log.trace "${map.inspect()}"

    try {
        // Save image from S3 bucket to S3 device cloud
        log.info "Saving picture to SmartThings"
        def lastImageUrl
        state.lastImageS3Url = lastImageUrl = getPictureName()
        storeTemporaryImage(map.tempImageKey, lastImageUrl)

        // getState()/getData() - gets a map of the state variable
        // getZwave() - gets physicalgraph.zwave.Zwave object
        // getLog() - gets various log objects (trace, debug, info, warn, error, fatal)

        /*log.trace "Getting S3 image ${lastImageUrl}" // we cannot use state.lastImageS3Url because it was modified in this function and the value isn't committed until the function exits
        def image = getImage(lastImageUrl)
        log.trace "Got image\n$image"
        if(image)
        {
            // Send the image to an App who wants to consume it via an event as a Base64 String
            //def bytes = image.buf
            //log.debug "JPEG Data Size: ${bytes.size()}"
            //String str = bytes.encodeBase64()
            //sendEvent(name: "imageDataJpeg", value: str, displayed: false, isStateChange: true)
            sendEvent(name: "imageDataJpeg", value: "", displayed: false, isStateChange: false) // Wipe it clean so it empties any old data

        } else {
            log.warn "No picture content, nothing to save"
        }*/
	}
	catch(Exception e) {
		log.error "Error processing image, Error: $e"
	}
}

// Process the response from the camera
private processResponse(String body) {
    //log.trace body
    if(hdcamera) {
        processHDResponse(body)
    } else {
        processSDResponse(body)
    }
}

private processHDResponse(body) {
    def statusVars = new XmlSlurper(false,false,true).parseText(body?.trim()?.replaceFirst("^([\\W]+)<","<")) // Some cameras create a malformed XML so ignore BOM's and extra characters before the start of the XML
    //log.trace "Vars -> ${body}"

    // Check the result value for the command sent
    switch (statusVars.result) {
        case "0":
            //log.warn "Camera responded with result ${statusVars.result} -> ALL's GOOD, THIS IS JUST A DEBUG" // Do nothing, this is good!
            break

        case "-1":
            def logErr = "Camera responded with result ${statusVars.result} -> CGI request string format error, your Username or Password may contain invalid character. The only allowed special characters are ~!@^*()_"
            log.error logErr
            sendEvent(name: "alarmStatus", value: "error", descriptionText: logErr, displayed: true, isStateChange: true)
            break

        case "-2":
            def logErr = "Camera responded with result ${statusVars.result} -> Invalid username or password. Check your Username and Password (BOTH are case sensitive)"
            log.error logErr
            sendEvent(name: "alarmStatus", value: "error", descriptionText: logErr, displayed: true, isStateChange: true)
            break

        case "-3":
            def logErr = "Camera responded with result ${statusVars.result} -> Access denied. Make sure the Username you've entered has Administrative rights on the camera"
            log.error logErr
            sendEvent(name: "alarmStatus", value: "error", descriptionText: logErr, displayed: true, isStateChange: true)
            break

        case "-4":
            def logErr = "Camera responded with result ${statusVars.result} -> CGI execution failed"
            log.error logErr
            sendEvent(name: "alarmStatus", value: "error", descriptionText: logErr, displayed: true, isStateChange: true)
            break

        case "-5":
            def logErr = "Camera responded with result ${statusVars.result} -> Timeout"
            log.error logErr
            sendEvent(name: "alarmStatus", value: "error", descriptionText: logErr, displayed: true, isStateChange: true)
            break

        case "-6":
            def logErr = "Camera responded with result ${statusVars.result} -> Reserved error"
            log.error logErr
            sendEvent(name: "alarmStatus", value: "error", descriptionText: logErr, displayed: true, isStateChange: true)
            break

        case "-7":
            def logErr = "Camera responded with result ${statusVars.result} -> Unknown error"
            log.error logErr
            sendEvent(name: "alarmStatus", value: "error", descriptionText: logErr, displayed: true, isStateChange: true)
            break

        case "-8":
            def logErr = "Camera responded with result ${statusVars.result} -> Reserved error"
            log.error logErr
            sendEvent(name: "alarmStatus", value: "error", descriptionText: logErr, displayed: true, isStateChange: true)
            break

        default:
            def logErr = "Camera responded with result ${statusVars.result} -> Unknown error"
            log.error logErr
            sendEvent(name: "alarmStatus", value: "error", descriptionText: logErr, displayed: true, isStateChange: true)
            break
    }

    // Get mirror and flip settings
    def flipS = "$statusVars.isFlip"
    def mirrorS = "$statusVars.isMirror"
    if (mirrorS?.trim() != "") {
        log.info "Polled: Mirror status $mirrorS"
        sendEvent(name: "mirrorStatus", value: mirrorS, displayed: false)
    }
    if (flipS?.trim() != "") {
        log.info "Polled: Flip status $flipS"
        sendEvent(name: "flipStatus", value: flipS, displayed: false)
    }

    //Get Motion Alarm Status
    def motionAlarmDetect = "$statusVars.motionDetectAlarm" // $statusVars.isEnable is used with getMotionDetectConfig
    def humanAlarmDetect = "$statusVars.humanDetectAlarmState" // Amba foscam (C2, R2, FI9900P)
    def soundAlarmDetect = "$statusVars.soundAlarm" // Sounds alarm
    //log.warn "motionAlarmDetect=$motionAlarmDetect, humanAlarmDetect=$humanAlarmDetect, soundAlarmDetect=$soundAlarmDetect"
    if(motionAlarmDetect == "2" || soundAlarmDetect == "2" || humanAlarmDetect == "2") {
        log.info("Polled: ${motionAlarmDetect == "2" ? "Motion" : (humanAlarmDetect == "2" ? "Human Motion" : "Sound Motion")} Alarm Alert!!")
        sendEvent(name: "alarmStatus", value: "alarm")
        sendEvent(name: "alarm", value: "both")
        sendEvent(name: "switch", value: "on")
        sendEvent(name: "motion", value: "active", descriptionText: "$device.displayName detected ${motionAlarmDetect == "2" ? "motion" : (humanAlarmDetect == "2" ? "human motion" : "sound motion")}")
    } else if(motionAlarmDetect == "1" || soundAlarmDetect == "1" || humanAlarmDetect == "1") {
        log.info("Polled: ${motionAlarmDetect == "1" ? "Motion" : (humanAlarmDetect == "1" ? "Human Motion" : "Sound Motion")} Alarm On")
        sendEvent(name: "alarmStatus", value: "on")
        sendEvent(name: "alarm", value: "both")
        sendEvent(name: "switch", value: "on")
        sendEvent(name: "motion", value: "inactive", descriptionText: "$device.displayName ${motionAlarmDetect == "1" ? "motion" : (humanAlarmDetect == "1" ? "human motion" : "sound motion")} stopped")
    } else if(motionAlarmDetect || soundAlarmDetect || humanAlarmDetect) {
        log.info("Polled: Motion Alarm Off")
        sendEvent(name: "alarmStatus", value: "off")
        sendEvent(name: "alarm", value: "off")
        sendEvent(name: "switch", value: "off")
        sendEvent(name: "motion", value: "inactive", descriptionText: "$device.displayName motion detection off")
    }

    // First get Get IR LED Status
    def ledS = "$statusVars.infraLedState"
    if(ledS == "1") {
        log.info("Polled: LED On")
        sendEvent(name: "irState", value: "on", displayed: false) // this is an internal variable to track the LED state
    } else if(ledS == "0") {
        log.info("Polled: LED Off")
        sendEvent(name: "irState", value: "off", displayed: false) // this is an internal variable to track the LED state
    }

    // Then Get IR LED Mode
    def ledM = "$statusVars.mode"
    if(ledM == "0") {
        sendEvent(name: "irMode", value: "auto", displayed: false) // this is an internal variable to track the LED state
        log.info("Polled: LED Mode Auto")
    } else if(ledM == "1") {
        sendEvent(name: "irMode", value: "manual", displayed: false) // this is an internal variable to track the LED state
        log.info("Polled: LED Mode Manual")
    }

    // Update LED Status
    def irState = device.currentValue("irState")
    def irMode = device.currentValue("irMode")
    switch (irState) {
        case "on":
            if (irMode == "auto") {
                sendEvent(name: "irState", value: "reset", displayed: false) // this is an internal variable to track the LED state
                sendEvent(name: "irMode", value: "reset", displayed: false) // this is an internal variable to track the LED state
                sendEvent(name: "ledStatus", value: "autoOn", displayed: false)
                log.trace "ledStatus autoOn"
            } else if (irMode == "manual") {
                sendEvent(name: "irState", value: "reset", displayed: false) // this is an internal variable to track the LED state
                sendEvent(name: "irMode", value: "reset", displayed: false) // this is an internal variable to track the LED state
                sendEvent(name: "ledStatus", value: "on", displayed: false)
                log.trace "ledStatus on"
            }
        	break
            
        case "off":
            if (irMode == "auto") {
                sendEvent(name: "irState", value: "reset", displayed: false) // this is an internal variable to track the LED state
                sendEvent(name: "irMode", value: "reset", displayed: false) // this is an internal variable to track the LED state
                sendEvent(name: "ledStatus", value: "autoOff", displayed: false)
                log.trace "ledStatus autoOff"
            } else if (irMode == "manual") {
                sendEvent(name: "irState", value: "reset", displayed: false) // this is an internal variable to track the LED state
                sendEvent(name: "irMode", value: "reset", displayed: false) // this is an internal variable to track the LED state
                sendEvent(name: "ledStatus", value: "off", displayed: false)
                log.trace "ledStatus off"
            }
        	break
    }
    
    // Update Preset Points (first 4 (0-3) are fixed, they are TopMost, BottomMost, LeftMost, RightMost, we capture the next 6 custom presets
    if ("$statusVars.point0"?.trim()) { // Convert XML node to string and check if it isn't empty
        // Update standard presets
        log.trace "First 4 fixed presets -> $statusVars.point0, $statusVars.point1, $statusVars.point2, $statusVars.point3"
        sendEvent(name: "presetTop", value: "topmost", displayed: false)
        sendEvent(name: "presetBottom", value: "bottommost", displayed: false)
        sendEvent(name: "presetLeft", value: "leftmost", displayed: false)
        sendEvent(name: "presetRight", value: "rightmost", displayed: false)
        
        (4..9).each {
            def presetName = "${statusVars."point${it}"}"
            log.trace "Found preset ${it - 3} -> $presetName"
            sendEvent(name: "preset${it - 3}", value: "${presetName ?: (it - 3)}", isStateChange: true, displayed: false) // Force UI update
        }
    }
    
    // Get user configured motion detection area for HD Cameras (getMotionDetectConfig)
    if ("$statusVars.area0"?.trim()) {// Check if it exists
        def areas = 0
        def detArea = ""
        (0..9).each { no ->
            areas += ("${statusVars."area${no}"}" as Integer) ?: 0
            detArea += (detArea ? "&" : "") + "area${no}=" + "${statusVars."area${no}"}"
        }
        if (areas) { // If they are all 0 then ignore it
            log.trace "Found area detection -> $detArea"
            sendEvent(name: "detectionArea", value: detArea, displayed: false)
        }
    }

    // Get user configured motion detection area for Ambarella Cameras (getMotionDetectConfig1)
    if ("$statusVars.valid1"?.trim()) {// Check if it exists
        def areas = 0
        def detArea = ""
        (1..3).each { no ->
            areas += ("${statusVars."valid${no}"}" as Integer) ?: 0
            detArea += (detArea ? "&" : "") + "x${no}=" + "${statusVars."x${no}"}"
            detArea += (detArea ? "&" : "") + "y${no}=" + "${statusVars."y${no}"}"
            detArea += (detArea ? "&" : "") + "width${no}=" + "${statusVars."width${no}"}"
            detArea += (detArea ? "&" : "") + "height${no}=" + "${statusVars."height${no}"}"
            detArea += (detArea ? "&" : "") + "threshold${no}=" + "${statusVars."threshold${no}"}"
            detArea += (detArea ? "&" : "") + "sensitivity${no}=" + "${statusVars."sensitivity${no}"}"
            detArea += (detArea ? "&" : "") + "valid${no}=" + "${statusVars."valid${no}"}"
        }
        if (areas) { // If they are all 0 then ignore it
            log.trace "Found ambarella area detection -> $detArea"
            sendEvent(name: "detectionArea", value: detArea, displayed: false)
        }
    }
}

private processSDResponse(body) {
    /*if (body?.length() > 2000) { // Doesn't always fit in one line so split it
        log.trace body.substring(0,2000)
        log.trace body.substring(2000)
    } else {
        log.trace body
    }*/
    
    // Check for an error in the result value of the command sent
    if (body.find("401 Unauthorized")) {
        log.error "Camera responded with an 401 Unauthorized error. Check you Username and Password (BOTH are case sensitive). Error -> ${body}"
        sendEvent(name: "alarmStatus", value: "error", descriptionText: "Invalid username and password (BOTH are case sensitive)", displayed: true, isStateChange: true)
        return
    } else if (body.find("illegal params")) {
        log.error "Camera responded with an error. Likely caused by an invalid Username or Password, check you Username and Password (BOTH are case sensitive). Error -> ${body}"
        sendEvent(name: "alarmStatus", value: "error", descriptionText: "Camera responded with an error, check logs", displayed: true, isStateChange: true)
        return
    }

    // First get the status and save it in the state variable
    if(body.find("alarm_status=1")) { // Check for active alarm
        log.info("Polled: Motion Alarm Alert!!")
        state.sdAlarmStatus = "Alarm"
    } else if(body.find("alarm_status=0")) {
        state.sdAlarmStatus = "None"
    }

    // Next get the motion but we can't save it in the state variable since the state variable is committed only when the function exits and we need to use it below
    def sdAlarmArmed
    if(body.find("alarm_motion_armed=0")) {
        log.info("Polled: Motion Alarm Off")
        sdAlarmArmed = "Off"
    }
    else if(body.find("alarm_motion_armed=1")) { // only check for "on" status when alarm is not active
        log.info("Polled: Motion Alarm On")
        sdAlarmArmed = "On"
    }

    // Check our state now and update the events
    //log.trace "Motion: ${state.sdAlarmStatus}, Armed: ${sdAlarmArmed}"
    if (sdAlarmArmed == "Off") { // First priority, if we're in off state then turn it off
        log.trace "Motiom alarm off"
        sendEvent(name: "alarmStatus", value: "off")
        sendEvent(name: "alarm", value: "off")
        sendEvent(name: "switch", value: "off")
        sendEvent(name: "motion", value: "inactive", descriptionText: "$device.displayName motion stopped")
        state.sdAlarmStatus = "None" // Since they are 2 different registers we can have have Alarm on but monitoring off, force Alarm off if monitoring is off
    } else if ((sdAlarmArmed == "On") && (state.sdAlarmStatus == "Alarm")) { // Next priority Alarm 
        log.trace "Motion alarm Alarmed"
        sendEvent(name: "alarmStatus", value: "alarm")
        sendEvent(name: "alarm", value: "both")
        sendEvent(name: "switch", value: "on")
        sendEvent(name: "motion", value: "active", descriptionText: "$device.displayName detected motion")
    } else if ((sdAlarmArmed == "On") && (state.sdAlarmStatus == "None")) { // If not in alarm check for On
        log.trace "Motion alarm on"
        sendEvent(name: "alarmStatus", value: "on")
        sendEvent(name: "alarm", value: "both")
        sendEvent(name: "switch", value: "on")
        sendEvent(name: "motion", value: "inactive", descriptionText: "$device.displayName motion stopped")
    }

    if(body.find("alarm_http=0")) {
        log.info("Polled: Motion Alarm Callback Notification Disabled")
    } else if(body.find("alarm_http=1")) {
        def callbackURL = (body =~ ".*?alarm_http_url='(.*?)'")[0][1]
        log.info("Polled: Motion Alarm Callback Notification Enabled with URL $callbackURL")
    }

    // Get mirror and flip settings
    if (body.find("flip=0")) {
        log.info "Polled: Flip Status 0, Mirror Status 0"
        sendEvent(name: "mirrorStatus", value: 0, displayed: false)
        sendEvent(name: "flipStatus", value: 0, displayed: false)
    } else if (body.find("flip=1")) {
        log.info "Polled: Flip status 1, Mirror Status 0"
        sendEvent(name: "mirrorStatus", value: 0, displayed: false)
        sendEvent(name: "flipStatus", value: 1, displayed: false)
    } else if (body.find("flip=2")) {
        log.info "Polled: Flip status 0, Mirror status 1"
        sendEvent(name: "mirrorStatus", value: 1, displayed: false)
        sendEvent(name: "flipStatus", value: 0, displayed: false)
    } else if (body.find("flip=3")) {
        log.info "Polled: Flip status 1, Mirror status 1"
        sendEvent(name: "mirrorStatus", value: 1, displayed: false)
        sendEvent(name: "flipStatus", value: 1, displayed: false)
    }
}

private getPictureName() {
  def pictureUuid = java.util.UUID.randomUUID().toString().replaceAll('-', '')
  "image" + "_$pictureUuid" + ".jpg"
}

private getHostAddress(host) {
	return "${host}:${port}"
}

private String convertIPtoHex(ipAddress) {
	// Check for valid IPv4 address, ST doesn't support IPv6 yet
    if (!isIPAddress(ipAddress)) {
        log.error "Invalid IP Address $ipAddress, check your settings!"
        return
    }
    
	try {
        String hex = ipAddress.tokenize( '.' ).collect {  String.format('%02x', it.toInteger() ) }.join()  // thanks to @pstuart
        return hex
    } catch (Exception e) {
        log.error "Invalid IP Address $ipAddress, check your settings! Error: $e"
    }
}

private String convertPortToHex(port) {
	if (!port || (port == 0)) {
    	log.error "Invalid port $port, check your settings!"
    }
    
    try {
        String hexport = port.toString().format('%04x', port.toInteger() )   // thanks to @pstuart
        return hexport
    } catch (Exception e) {
        log.error "Invalid port $port, check your settings! Error: $e"
    }
}

private Integer hexToInt(hex) {
    return Integer.parseInt(hex, 16)
}

private String hextoPort(hex) {
    try {
        hexToInt(hex)
    } catch (e) {
        log.error "Invalid HEX, cannot convert to Port"
    }
}

private String convertHextoIP(String hex) {
    try {
        [ hexToInt(hex[0..1]), hexToInt(hex[2..3]), hexToInt(hex[4..5]), hexToInt(hex[6..7]) ].join(".")
    } catch (e) {
        log.error "Invalid HEX, cannot convert to IP Address"
    }
}

private String getDetectionArea() {
    def area = device.currentValue("detectionArea")
	log.trace "Retrieved area detection:$area"
    
    if (area?.trim()) {
    	// Remove any trailing or leading & if entered accidentally
        area = area.replaceAll("^&+", "") // Leading &
    	area = area.replaceAll("&+\$", "") // Trailing &
        return area
    } else {
        if (cameraModel == "Amba") { // Amba cameras have 3 detection areas with separate sensitivity levels
            return "x1=0&y1=0&width1=10000&height1=10000&sensitivity1=${getMotionLevel(motionLevel)}&valid1=1" // Default is full frame detection at specified sensitivity using a single area, areas 2 and 3 are disabled by default
        } else {
            return "area0=1023&area1=1023&area2=1023&area3=1023&area4=1023&area5=1023&area6=1023&area7=1023&area8=1023&area9=1023" // Default is full frame detection
        }
    }
}

private String getMotionLevel(motion) {
	log.trace "Motion detection level requested is $motion"

	String retVal = ""
    
    switch (motion) {
    	case "Lowest":
        	if (hdcamera)
        		retVal = "4"
        	else
                retVal = "9"
            break
            
    	case "Lower":
        	if (hdcamera)
        		retVal = "3"
        	else
                retVal = "7"
            break
            
    	case "Low":
        	if (hdcamera)
        		retVal = "0"
        	else
                retVal = "5"
            break
            
    	case "Medium":
        	if (hdcamera)
        		retVal = "1"
        	else
                retVal = "3"
            break
            
    	case "High":
        	if (hdcamera)
        		retVal = "2"
        	else
                retVal = "0"
            break
            
		default:
        	log.warn "Invalid motion level $motion, check your settings, reverting to default"
            
        	if (hdcamera)
        		retVal = "1"
        	else
                retVal = "3"
            break
    }
    
    log.trace("Motion detection value is $retVal")
    
    return retVal
}

private String getSoundLevel(sound) {
	log.trace "Sound detection level requested is $sound"

	String retVal = ""
    
    // For SD cameras the range is 0-9, 0 is the highest sensitivity
    // For HD cameras the range is 0-2, 0=low 1=middle 2=high sensitivity
    // For Ambarella cameras the range is 0-4, 4 - Lowest, 3 - Lower, 0 - Low, 1 - Medium, 2 - High
    switch (sound) {
    	case "Lowest":
        	if (hdcamera) {
                if (cameraModel == "Amba") {
                    retVal = "4"
                } else {
                    retVal = "0"
                }
            } else {
                retVal = "9"
            }
            break
            
    	case "Lower":
        	if (hdcamera) {
                if (cameraModel == "Amba") {
                    retVal = "3"
                } else {
                    retVal = "0"
                }
            } else {
                retVal = "7"
            }
            break
            
    	case "Low":
        	if (hdcamera) {
                if (cameraModel == "Amba") {
                    retVal = "0"
                } else {
                    retVal = "1"
                }
            } else {
                retVal = "5"
            }
            break
            
    	case "Medium":
        	if (hdcamera) {
                if (cameraModel == "Amba") {
                    retVal = "1"
                } else {
                    retVal = "1"
                }
            } else {
                retVal = "3"
            }
            break
            
    	case "High":
        	if (hdcamera) {
                if (cameraModel == "Amba") {
                    retVal = "2"
                } else {
                    retVal = "2"
                }
            } else {
                retVal = "0"
            }
            break
            
		default:
        	log.warn "Invalid sound detection level $sound, check your settings, reverting to default"
            
        	if (hdcamera) {
                if (cameraModel == "Amba") {
                    retVal = "4"
                } else {
                    retVal = "0"
                }
            } else {
                retVal = "9"
            }
            break
    }
    
    log.trace("Sound detection value is $retVal")
    
    return retVal
}

private String getReArmInterval(interval) {
	log.trace("Trigger/ReArm internal is $interval")

	String retVal = ""
    
    switch (interval) {
    	case "5s":
        	retVal = "0"
            break
            
    	case "6s":
        	retVal = "1"
            break
            
    	case "7s":
        	retVal = "2"
            break
            
    	case "8s":
        	retVal = "3"
            break
            
    	case "9s":
        	retVal = "4"
            break
            
    	case "10s":
        	retVal = "5"
            break
            
    	case "11s":
        	retVal = "6"
            break
            
    	case "12s":
        	retVal = "7"
            break
            
    	case "13s":
        	retVal = "8"
            break
            
    	case "14s":
        	retVal = "9"
            break
            
    	case "15s":
        	retVal = "10"
            break
            
		default:
        	log.warn "Invalid trigger interval $interval, check your settings, reverting to default 10"
            
        	retVal = "10"
            break
    }

	log.trace("Snap interval value is $retVal")
    
    return retVal
}

private String getMotionAlarmEvents() {
	int ret = 0 // Default nothing to enable
    
    if (motionRing) {
    	ret |= 0x1 // Enable local ringer
	    log.trace "Enabled motion ringer, $ret"
    }
    
    if (motionEMail) {
    	ret |= 0x2 // Enable sending eMails
	    log.trace "Enabled motion eMail, $ret"
    }
    
    if (motionSnap) {
    	ret |= 0x4 // Enable taking pictures
	    log.trace "Enabled motion snap pictures, $ret"
    }
    
    if (motionRecord) {
    	ret |= 0x8 // Enabling taking a video recording
	    log.trace "Enabled motion video recording, $ret"
    }
    
    log.trace "Motion alarm config value $ret"

    return ret.toString()
}

private String getAmbaMotionAlarmEvents() {
	int ret = 0 // Default nothing to enable
    
    if (motionRing) {
    	ret |= 0x1 // Enable local ringer
	    log.trace "Enabled motion ringer, $ret"
    }
    
    if (motionEMail) {
    	ret |= 0x2 // Enable sending eMails
	    log.trace "Enabled motion eMail, $ret"
    }
    
    if (motionSnap) {
    	ret |= 0x4 // Enable taking pictures
	    log.trace "Enabled motion snap pictures, $ret"
    }
    
    if (motionRecord) {
    	ret |= 0x8 // Enabling taking a video recording
	    log.trace "Enabled motion video recording, $ret"
    }
    
    if (uploadCloud) {
    	ret |= (0x20 | 0x40) // Enabling uploading photo and recording to cloud
	    log.trace "Enabled uploading photo and recording to cloud, $ret"
    }
    
    if (pushFoscamPhoneApp) {
    	ret |= 0x80 // Enabling pushing message to native foscam app
	    log.trace "Enabled push message to native foscam phone app, $ret"
    }
    
    log.trace "Motion alarm config value $ret"

    return ret.toString()
}

private boolean isIPAddress(String ipAddress) {
    try
    {
         String[] parts = ipAddress.split("\\.")
         if (parts.length != 4) {
         	return false
         }
         for (int i = 0; i < 4; ++i)
         {
             int p = Integer.parseInt(parts[i])
             if (p > 255 || p < 0) {
             	return false
             }
         }
         return true
    } catch (Exception e)
    {
        return false
    }
}

private String convertHostnameToIPAddress(hostname) {
    def params = [
        uri: "https://dns.google.com/resolve?name=" + hostname,
        contentType: 'application/json'
    ]

    def retVal = null

    try {
        retVal = httpGet(params) { response ->
            log.trace "Request was successful, data=$response.data, status=$response.status"
            //log.trace "Result Status : ${response.data?.Status}"
            if (response.data?.Status == 0) { // Success
                for (answer in response.data?.Answer) { // Loop through results looking for the first IP address returned otherwise it's redirects
                    //log.trace "Processing response: ${answer}"
                    if (isIPAddress(answer?.data)) {
                        log.trace "Hostname ${answer?.name} has IP Address ${answer?.data}"
                        return answer?.data // We're done here (if there are more ignore it, we'll use the first IP address returned)
                    } else {
                        log.trace "Hostname ${answer?.name} redirected to ${answer?.data}"
                    }
                }
            } else {
                log.warn "DNS unable to resolve hostname ${response.data?.Question[0]?.name}, Error: ${response.data?.Comment}"
            }
        }
    } catch (Exception e) {
        log.warn("Unable to convert hostname to IP Address, Error: $e")
    }

    //log.trace "Returning IP $retVal for Hostname $hostname"
    return retVal
}

// Check if an ipAddress is a public ip address
private boolean isPublicIPAddress(String ipAddress) {
    try {
    	// Check for private IP Addresses
        // 0.255.255.255  (0/8 prefix) (all local)
        // 127.255.255.255  (127/8 prefix) (loopback)
        // 10.255.255.255  (10/8 prefix)
        // 172.31.255.255  (172.16/12 prefix)
        // 192.168.255.255 (192.168/16 prefix)
        // 169.254.255.255 (169.254/16 prefix) (link local)
        // Between 224.0.0.1 and 239.255.255.255 (multicast addresses)
    	if (ipAddress.find(/(^0\.)|(^127\.)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)|(^169\.254\.)|(^22[4-9]\.)|(^23[0-9]\.)/)) {
            log.trace "IPAddress $ipAddress is a private IP Address"
            return false
        } else {
            log.trace "IPAddress $ipAddress is a public IP Address"
            return true
        }
    } catch (Exception e) {
    	log.error "Invalid IPAddress $ipAddress"
        return false
    }
}

// Executes a delay in ms
private delayMs(delay) {
    if (!delay) { return }
    def end = now() + delay
    while (now() <= end) { }
}

// Update a user preference setting
private updateSetting(name, value) {
    device.updateSetting(name, value) // THIS IS A VERY SLOW TRANSACTION as it writes directly to the DB
}

// Delete a user preference setting
private deleteSetting(name) {
    device.updateSetting(name, '') // THIS IS A VERY SLOW TRANSACTION as it writes directly to the DB
}

// Rate Limit to 10 Transactions per 60 seconds
private rateLimitExceeded(def x = "", def reset = false) {
    def retVal = false
    def rate = 10 // unit: transactions
    def per  = 60 * 1000 // unit: milliseconds
    
    // Changes to State variables are not committed until the function exist, hence we can't write and read back in the same function
    def allowance = state."allowance${x}"
    def last_check = state."last_check${x}"
    
    if (reset || !allowance) {
        allowance = rate // unit: transactions
        log.trace "Initializing Allowance $x: ${allowance}"
        if (reset) {
            return false
        }
    }
    if (reset || !last_check) {
        last_check = now() // Unit: milliseconds
        log.trace "Initializing Last Check $x: ${new Date(last_check)}"
        if (reset) {
            return retVal
        }
    }

    def current = now() // Unit: milliseconds
    def time_passed = current - last_check // Unit: milliseconds
    log.trace "Passed $x: ${time_passed/1000} seconds"
    last_check = current
    allowance = (allowance + (time_passed * (rate / per))) as BigDecimal // Patch as ST doesn't support float yet
    if (allowance > rate) {
        allowance = rate // throttle
    }
    if (allowance < 1) {
        retVal = true // discard transaction
        // Disable the next line if you don't want to penalize repeat offenders and allow it to reset after the duration (per)
        allowance = allowance - 1 // Continue to deplete the count to block continuous offenders
    } else {
        retVal = false // continue with transactions
        allowance = allowance - 1
    }
    
    log.trace "Allowance $x: ${allowance}, Last Check: ${new Date(last_check)}"
    
    state."allowance${x}" = allowance // finally update it
    state."last_check${x}" = last_check // finally update it
    
    return retVal
}

// THIS IS THE END OF THE FILE