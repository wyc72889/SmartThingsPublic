/*
 * -----------------------
 * ------ SMART APP ------
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "03.01.00"
}

/**
* Foscam Motion Alarm Monitor
*
* Author: RBoy Apps
* Copyright RBoy Apps, redistribution, reuse or modification of code is not allowed without permission
* 2019-01-07 - (v03.01.00) Fixed an issue with detection cameras which are in motion detection on while initializing app and potential race when using multiple cameras, support for mixed push/pull cameras, improved UI and added option for audio notifications
* 2019-01-02 - (v03.00.09) Detection area is now retrieved from the camera instead of a user input
* 2018-12-21 - (v03.00.08) Added R2E to Ambarella chipsets
* 2018-10-16 - (v03.00.07) Compatibility with new ST app
* 2018-08-08 - (v03.00.06) Optimize discovery of cameras
* 2018-04-10 - (v03.00.05) Restriction interval from 1 to 10 seconds otherwise the camera motion detection doesn't register, remove sunset/sunrise handler
* 2018-02-08 - (v03.00.02) Added support for default/custom Ambarella detection area
* 2017-12-08 - (v03.00.02) Fix for C2 and some HD cameras error while processing discovery response and fix for SHM not arming/disarming cameras
* 2017-11-01 - (v03.00.01) Added support for default sound detection level
* 2017-10-23 - (v03.00.00) Updated to automatically discover and install Foscam cameras
* 2017-05-26 - (v02.07.02) Multiple SMS numbers are now separate by a *
* 2017-01-12 - (v2.7.1) Added option to disarm cameras on Stay SHM
* 2017-01-02 - (v2.7.1) Fixed LongURL for SD cameras callback (service expired)
* 2016-11-05 - Added support for automatic code update notifications and fixed an issue with sms
* 2016-09-06 - Added notification for user if they "forgot" to enable OAuth for the SmartApp
* 2016-08-17 - Added support for ST contact address book
* 2016-06-27 - Improve SHM integration
* 2016-06-23 - Allow you to change the name of the app
* 2016-06-07 - Correct mode name of SHM to Disarm in options
* 2016-03-18 - Debug message fix
* 2016-03-08 - Added integration with SHM for arming/disarming camera
* 2016-03-07 - Updated the push callback URL for SD cameras as per the new ST format
* 2016-03-07 - Only kick start monitor task from heartbeat if the monitor task is active
* 2016-03-06 - Improve heartbeat reliability
* 2016-03-05 - Brand new scheduling system to make motion detection more reliable and resistant to the broken ST platform timer issues
* 2016-01-17 - Can send SMS's to multiple people, separate with + e.g. 5551234567+4447654321
* 2016-01-10 - Included hideable sections in the setup options for better layout
* 2016-01-09 - Added support for changing camera presets based on people (presence sensors) arrival notifications
* 2015-11-02 - Added notification for alarm
* 2015-10-25 - Added support for assigning presets for each mode
* 2015-09-26 - Updated layout and added explanations
* 2015-09-26 - Added a 2 second delay before starting cruise when motion alarm is detection to avoid picture tearing
* 2015-09-10 - Updated to comlpy with new platform changes for API Server URL
* 2015-09-01 - Added option to turn off Light after some time (configurable), improved SD camera push motion callback status update
* 2015-08-25 - Fixed support for push notifications with SD Foscam (finally)
* 2015-08-24 - Pull is the default mode for checking for Alarms, user can force Push mode if camera supports it (but may not work currently due to URL shortening limitations of Foscam)
* 2015-08-24 - Ignore motion events from camera's not being actively monitored (phantom events)
* 2015-08-23 - Fixed issue with Push notifications not updating status
* 2015-08-23 - Added option to Start/Stop camera cruise on external alarms
* 2015-08-23 - Added support for Modes to disable alarms when not in selected modes
* 2015-08-23 - Added support for Shortened URL's for push notifications to workaround the 128 character limit for SD cameras and option to disable Push notifications in the settings
* 2015-08-23 - Added support for Camera pull/push notifications
* 2015-08-14 - Added support for SD Camera's Motion Detection support
* 2015-08-13 - Fix for Android ST app not able to install due to broken platform changes
* 2015-08-12 - Added support to reset to the specified present position when the motion detection is disabled
* 2015-07-26 - Added support to start cruise when motion alarm is detected
* 2015-06-19 - Added support for taking pictures
* 2015-06-18 - Initial version
*/

definition(
    name: "Foscam Camera and Motion Alarm Manager",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Discovers and installs your Foscam cameras and activates motion alarm notifications",
    category: "Safety & Security",
    iconUrl: "https://s3.amazonaws.com/smartapp-icons/Partner/foscam.png",
    iconX2Url: "https://s3.amazonaws.com/smartapp-icons/Partner/foscam@2x.png",
    singleInstance: true)

preferences {
	page(name: "discoverFoscamCameras", title:"Foscam Camera Discovery")
	page(name: "configureFoscam", title: "Foscam Camera Setup")
    page(name: "configurePage")
    page(name: "motionActionsPage")
    page(name: "externalAlarmCruisePage")
    page(name: "modePresetsPage")
    page(name: "presencePresetsPage")
    page(name: "shmIntegrationPage")
    page(name: "cameraSettings")
}

import groovy.json.JsonSlurper
import groovy.transform.Synchronized

private getMaxCameras() { 5 }

def discoverFoscamCameras() {
    dynamicPage(name:"discoverFoscamCameras", title: "Foscam Camera and Motion Alarm Manager v${clientVersion()}", nextPage:"configureFoscam", refreshInterval:1) {
        if(!state.subscribe) {
            log.trace "Clearing initial settings"
            state.cameras = [:] // Reset it on each start do we get a clean list of cameras if IP's have changed
            //deleteSetting("selectedFoscam") // Clear any previously selected discovered cameras
            (0..(maxCameras - 1)).each { num ->
                settingsDelete(num) // Clear all slots when the app starts
            }
            subscribe(location, null, locationHandler, [filterEvents:false])
            state.subscribe = true
        }

        // discovery search, get hub IP address, the camera needs to be on the same network (workaround for now since broadcast packets don't work with the hub)
        def physicalHubs = location.hubs.findAll { it.type == physicalgraph.device.HubType.PHYSICAL } // Ignore Virtual hubs
        def hub = physicalHubs[0]
        def localNet = hub.localIP.replaceFirst(/\d+$/, "") // Remove the last IP after the .
        int startIP = 1
        int lastIP = 254
        int nextIP
        (1..3).each { // Do multiple discoveries at a time to speed it up (too many and the platform will time out, 3 is max). TODO: What's the optimial number and how do we optimize this (1 is best 5 seems to miss on Android)
            if(!state.nextIP) {
                log.debug "Found hub with name: ${hub.name}, localIP: ${hub.localIP}"
                nextIP = startIP
            } else {
                nextIP = state.nextIP
            }
            if (nextIP > lastIP) { // Reset counter
                nextIP = startIP
            }
            discoverCameras(localNet + nextIP as String) // Do one IP discovery
            state.nextIP = nextIP + 1
        }
        //discoverCameras(localNet + "255") // Do one subnet broadcast discovery
        //discoverCameras("255.255.255.255") // Do on broadcast discovery - can't do broadcast since the ST shows response from IP 255.255.255.255

        def options = getDiscoveredCameras().collectEntries { [(it.key), (it.value.name ?: "Foscam Camera")] } // Consolidated the list of discovered cameras in the format [key:name]
        def numFound = options.size() ?: 0
        // Android is broken for now so we'll take all the cameras for now, it doesn't save selection https://community.smartthings.com/t/android-2-8-0-refreshinterval-causes-selections-to-reset/103127
        /*section("Please wait while we discover your Foscam cameras.\nDiscovery can take five minutes or more, so sit back and relax!") {
            paragraph "Select the cameras to install once discovered or go to the next page to manually enter camera details."
            input "selectedFoscam", "enum", title:"${numFound} Foscam(s) discovered", description: "Tap to select cameras", multiple:true, options:options, defaultValue: options*.key, required:false
        }*/        
        section("Please wait while we discover your Foscam cameras.\nDiscovery can take five minutes or more, so sit back and relax!") {
            paragraph "Go to the next page once cameras are discovered or to manually enter camera details."
            paragraph "${numFound} Foscam(s) discovered\n\n${options*.value?.join("\n")}"
        }
        
        remove("Uninstall Foscam Manager")
    }
}

def configureFoscam() {
    dynamicPage(name: "configureFoscam", title: "Foscam Camera Setup", nextPage:"configurePage", refreshInterval: 5, uninstall: false) { // Update every 5 seconds to check on incomplete configurations
        section("Installed Cameras") {
            if (cameras) {
                paragraph "Enable buttons to uninstall cameras"
            }
            cameras.each { cam -> // Show each installed camera
                input "delete${cam.deviceNetworkId}", "bool", title: "${cam.displayName}", description: settings."delete${cam.deviceNetworkId}" ? "Marked for deletion" : "Tap button to delete", submitOnChange: true, required: false
                (0..(maxCameras - 1)).each { num ->
                    if (settings."name${num}" == cam.label) { // If the installed camera occupied this slot
                        settingsDelete(num) // clear the slot for reuse by next camera
                    }
                }
            }
        }

        section("New Cameras") {
            paragraph "Tap each camera to verify settings"

            if ((0..(maxCameras - 1)).any { num -> !settingsComplete(num) && settings."name${num}"}) {
                paragraph title: "WARNING: Cameras with incomplete configurations will not be installed", required: true, ""
            }
            
            def cams = cameras // Get list of installed cameras
            def selectedFoscam = getDiscoveredCameras().collect { (it.key) } // Since Android is broken for now select all found cameras and save key
            (0..(maxCameras - 1)).each { num ->
                if (getDiscoveredCameras() && selectedFoscam && selectedFoscam[num]) { // If we have a discovered & selected camera, pre populate it
                    def camD = getDiscoveredCameras().find { it.key == selectedFoscam[num] } // Find the camera selected
                    if (camD && !cams.any { it.deviceNetworkId?.toLowerCase() == camD.key?.toLowerCase() }) { // Only show cameras that aren't installed already
                        def cam = camD.value
                        if (settings."name${num}" != cam.name) { // If the discovered camera did not occupy this slot then clear it so it replaces the information
                            settingsDelete(num) // clear the slot for reuse by discovered camera
                            updateSetting("name${num}", cam.name) // Force the name in so it will show up as incomplete settings if the settings are incomplete
                        }
                        def hrefParams = [num: num as String, cam: cam, passed: true] // use as String otherwise it won't work on Android
                        href(name: "camera${num}", params: hrefParams, title: "${cam.name}", page: "cameraSettings", description: settingsComplete(num) ? "Ready to install" : "INCOMPLETE CONFIGURATION!!", required: false)
                    } else {
                        if (settings."name${num}" == camD?.value?.name) { // If the discovered camera occupied this slot
                            settingsDelete(num) // clear the slot for reuse by next camera
                        }
                        def hrefParams = [num: num as String, passed: true] // use as String otherwise it won't work on Android
                        href(name: "camera${num}", params: hrefParams, title: settings."name${num}" ?: "+ Add camera", page: "cameraSettings", description: settings."name${num}" ? (settingsComplete(num) ? "Ready to install" : "INCOMPLETE CONFIGURATION") : "", required: false)
                    }
                } else {
                    def hrefParams = [num: num as String, passed: true] // use as String otherwise it won't work on Android
                    href(name: "camera${num}", params: hrefParams, title: settings."name${num}" ?: "+ Add camera", page: "cameraSettings", description: settings."name${num}" ? (settingsComplete(num) ? "Ready to install" : "INCOMPLETE CONFIGURATION") : "", required: false)
                }
            }
        }
    }
}

def cameraSettings(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def num
    def cam
    // Get user from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.num) {
        num = params.num
        cam = params.cam
        log.trace "Passed from main page, using params lookup for num $num and cam $cam"
    } else if (atomicState.params) {
        num = atomicState.params.num ?: 0
        cam = atomicState.params.cam ?: []
        log.trace "Passed from submitOnChange, atomicState lookup for num $num and cam $cam"
    } else {
        log.error "Invalid params, no params found. Params: $params, saved params: $atomicState.params"
    }
    
    log.trace "Camera Settings Page, num:$num, cam:$cam, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"cameraSettings", title: "Camera Settings", uninstall: false, install: false) {
        section() {
            input "name${num}", "text", title:"Name", description: "SmartThings camera name", defaultValue: cam ? cam.name : "", required: false
            input "ip${num}", "text", title:"IP Address/Public Hostname", description: "Camera IP address or DNS hostname", defaultValue: cam ? convertHexToIP(cam.ip) : "", required: false
            input "port${num}", "number", title:"Port", description: "Camera Port", defaultValue: cam ? convertHexToPort(cam.port) : 88, required: false
            input "username${num}", "text", title:"Administrator username (case sensitive)", description: "Camera Administrative rights username (case sensitive)", required: false
            input "password${num}", "password", title:"Password (case sensitive)", description: "Camera password (case sensitive)", required: false
            input "hdcamera${num}", "bool", title:"Enable this if the camera is a HD model (720p or higher)?", description: "HD camera", defaultValue: cam ? cam.hd : true, required: false
            input "cameraModel${num}", "enum", title:"Select your camera model", multiple: false, options: ["Others":"Other Foscam","Amba":"C2/R2/R2E/R4/FI9900P"], description: "Select Other Foscam if your camera model isn't listed here", defaultValue: (cam ? (cam.hd ? "" : "Others") : ""), required: false
        }
    }
}

// Check if all camera settings are entered
private settingsComplete(num) {
    return settings."name${num}" && settings."ip${num}" && settings."port${num}" && settings."username${num}" && settings."cameraModel${num}"
}

// Delete all camera settings for slot
private void settingsDelete(num) {
    deleteSetting("name${num}")
    deleteSetting("ip${num}")
    deleteSetting("port${num}")
    deleteSetting("username${num}")
    //deleteSetting("password${num}") // Don't clear password since it leave **** even for empty
    deleteSetting("hdcamera${num}")
    deleteSetting("cameraModel${num}")
}

// Get new configured cameras (not installed) list with complete configurations in the format [dni:dni, prefs:[camera prefernces], name: name]
private getNewConfiguredCameras() {
    def cams = []
    (0..(maxCameras - 1)).each { num ->
        // Setup the camera preferences to initialize the camera on install (put all defaultValue: true settings here in addition to user configured settings)
        def cam = [:]
        cam.ip = settings."ip${num}"
        cam.port = settings."port${num}"
        cam.username = settings."username${num}"
        cam.password = settings."password${num}"
        cam.hdcamera = settings."hdcamera${num}"
        cam.cameraModel = settings."cameraModel${num}"
        cam.motionLevel = "Medium" // default
        cam.soundLevel = "Lowest" // default
        cam.motionEMail = true // default
        cam.motionSnap = true // default
        cam.motionRecord = true // default
        cam.motionRing = true // default
        cam.motionAlarmEnable = true // default
        cam.pirAlarmEnable = true // default
        cam.lightCompensation = true // default
        cam.humanSensitivity = "100" // default
        
        if (settingsComplete(num)) {
            //cams << [dni: "${cam.name.replaceAll("\\W","")}", prefs: cam, name: settings."name${num}"] // (we need a unique dni which is the camera name, remove all non word characters from name)
            cams << [dni: "${convertIPtoHex(cam.ip)}:${convertPortToHex(cam.port)}", prefs: cam, name: settings."name${num}"] // (we need a unique dni which is the ip:port in hex)
        }
    }
    log.trace "Configured Cameras: ${cams}"
    return cams
}

def configurePage() {
    dynamicPage(name: "configurePage", title: "Configure Cameras", install: true, uninstall: true) {    
        section () {
            if (!cruiseNames || !presetNames) {
                paragraph title: "These settings will be available the next time you open the app", required: true, ""
            } else {
                href(name: "motionActions", title: "Motion detected actions", page: "motionActionsPage", description: motionActionsDescription(), required: false)
                href(name: "externalAlarmCruise", title: "External alarm actions", page: "externalAlarmCruisePage", description: externalAlarmCruiseDescription(), required: false)
                href(name: "modePresets", title: "Presets for modes", page: "modePresetsPage", description: modePresetsDescription(), required: false)
                href(name: "presencePresets", title: "Presets for people", page: "presencePresetsPage", description: presencePresetsDescription(), required: false)
            }
            href(name: "shmIntegration", title: "Smart home monitor integration", page: "shmIntegrationPage", description: shmIntegrationDescription(), required: false)
        }
        
        section("Advanced Alarm Detection Settings (optional)", hidden: true, hideable: true) {
            paragraph "Some Foscam cameras support Push notifications. Enable this option to use push alarm notifications which are more reliable. If push alarm notifications are not working, try turning it off. Make sure you have configured a valid DNS server on camera to use this."
            input "enablePush", "bool", title: "Use Push Alarm Detection Mechanism", description: "Enable this option if your camera is able to send push notifications (check DNS settings on camera)", required: false, defaultValue: true
            paragraph title: "Some Foscam cameras provide alarm notifications through polling\nWARNING: change this setting ONLY if your camera motion poll settings do not match the default value (5)", required: true, ""
            input "interval", "number", title:"Motion alarm check interval (in seconds)", range: "1..10", defaultValue: 5, required: true
        }
        
        section() {
            input name: "updateNotifications", title: "Check for new versions of the app", type: "bool", defaultValue: true, required: false
        }
        remove("Uninstall Foscam Manager")
    }
}

def motionActionsPage() {
    dynamicPage(name: "motionActionsPage", title: "Motion Detected Action Settings") {    
        section() {
            paragraph "When motion is detected on the camera do these things..."
            input "audioDevices", "capability.audioNotification", title: "Play notifications on these devices", required: false, multiple: true, image: "http://www.rboyapps.com/images/Horn.png"
            input("recipients", "contact", title: "Send notifications to", multiple: true, required: false, image: "http://www.rboyapps.com/images/Notifications.png") {
                paragraph "You can enter multiple phone numbers by separating them with a '*'\nE.g. 5551234567*+448747654321"
                input "sms", "phone", title: "Send SMS notification to", required: false, image: "http://www.rboyapps.com/images/Notifications.png"
                input "push", "bool", title: "Send Push Notification", required: false
            }
            input "alarms", "capability.alarm", title: "Turn on these alarm(s)...", multiple: true, required: false, submitOnChange:true
            if (alarms) {
                input "alarmSilent", "bool", title: "...as silent alarm(s)", description: "activate only strobe light", required: false
            }
            input "lights", "capability.switch", title: "Turn on these switch(s)...", multiple: true, required: false, submitOnChange:true
            if (lights) {
                input "lightTimer", "number", title: "...turn off switches after (min)", description: "Leave blank to not turn off switch(s)", required: false
            }
            input "picture", "bool", title: "Take a picture with the camera", required: false
            cameras.each { camera ->
                input "cruisemap${camera}", "enum", title: "Activate cruise on $camera", options: cruiseNames, description: "Start this cruise action when motion is detected", required: false
            }
            cameras.each { camera ->
                input "resetPreset${camera}", "enum", title: "Reset $camera to preset", options: getPresetNames(camera), description: "When motion detection is stopped set the camera to this preset position", required: false
            }
            input "modeMonitor", "mode", title: "Operate only when in these mode(s)", description: "Enable motion notifications/actions only in the following mode(s)", required: false, multiple: true
        }
    }
}

def externalAlarmCruisePage() {
    dynamicPage(name: "externalAlarmCruisePage", title: "External Alarm Camera Actions") {
        section() {
            paragraph "Use this to start/stop the camera cruise actions and reset the camera position when an external alarm device is turned on/off"
            input "extAlarms", "capability.alarm", title: "When these Alarm(s) turn on/off...", multiple: true, required: false, submitOnChange:true
            if (extAlarms) {
                cameras.each { camera ->
                    input "extCruisemap${camera}", "enum", title: "...start/stop cruise on ${camera}", options: cruiseNames, description: "Start/stop this cruise action when external alarm(s) is turned on/off", required: false
                }
                cameras.each { camera ->
                    input "extResetPreset${camera}", "enum", title: "...reset ${camera} to preset", options: getPresetNames(camera), description: "When Alarm(s) is turned off, set the camera to this preset position", required: false
                }
            }
        }
    }
}

def shmIntegrationPage() {
    dynamicPage(name: "shmIntegrationPage", title: "Smart Home Monitor (SHM) Integration") {    
        section () {
            paragraph "Use these options to Enable/Disable Motion Detection when SHM is Armed/Disarmed"
            input "armAway", "bool", title: "Enable Motion Detection on Away", required: false
            if (!disarmStay) {
                input "armStay", "bool", title: "Enable Motion Detection on Stay", required: false, submitOnChange: true
            }
            if (!armStay) {
                input "disarmStay", "bool", title: "Disable Motion Detection on Stay", required: false, submitOnChange: true
            }
            input "disarmOff", "bool", title: "Disable Motion Detection on Disarm", required: false
        }
    }
}

def modePresetsPage() {
    dynamicPage(name: "modePresetsPage", title: "", install: false, uninstall: false) {    
        section("About") {
            paragraph "Use this page to reset the camera to specific presets for each specified mode. Leave it the preset blank for a mode if you don't want a specific preset assigned to a specific mode."
            input "individualModePresets", "bool", title: "Separate presets for each camera", submitOnChange: true
        }

        if (individualModePresets) {
            cameras.each { camera ->
                modePresetsInputs(camera)
            }
        } else {
            modePresetsInputs()
        }
    }
}

private modePresetsInputs(camera = "") {
    section ("Assign camera ${camera ?: ''} preset for each mode") {
        for (mode in location.modes) {
            def lastPreset = settings."preset${mode}${camera}"
            log.trace "Last preset for camera $camera and mode $mode is $lastPreset"
            if (lastPreset) {
                input name: "preset${mode}${camera}", type: "enum", title: "Mode ${mode}", options: getPresetNames(camera), defaultValue: lastPreset, description: "Select preset", required: false
            } else {
                input name: "preset${mode}${camera}", type: "enum", title: "Mode ${mode}", options: getPresetNames(camera), description: "Select preset", required: false
            }
        }
    }
}

def presencePresetsPage() {
    dynamicPage(name: "presencePresetsPage", title: "", install: false, uninstall: false) {    
        section("About") {
            paragraph "Use this page to reset the camera to specific presets based on arrival notifications."
            input name: "peoplePresets", type: "capability.presenceSensor", title: "Select people to assign presets", description: "Select preset", multiple: true, required: false, submitOnChange:true
            input "individualPresencePresets", "bool", title: "Separate presets for each camera", submitOnChange: true
        }

        if (individualPresencePresets) {
            cameras.each { camera ->
                presencePresetsInputs(camera)
            }
        } else {
            presencePresetsInputs()
        }
    }
}

private presencePresetsInputs(camera = "") {
    section ("Assign camera ${camera ?: ''} preset for each person") {
        for (person in settings."peoplePresets") {
            def lastPreset = settings."preset${person}${camera}"
            log.trace "Last preset for camera $camera and presence $person is $lastPreset"
            if (lastPreset) {
                input name: "preset${person}${camera}", type: "enum", title: "${person} arrives", options: getPresetNames(camera), defaultValue: lastPreset, description: "Select preset", required: false
            } else {
                input name: "preset${person}${camera}", type: "enum", title: "${person} arrives", options: getPresetNames(camera), description: "Select preset", required: false
            }
        }
    }
}

private shmIntegrationDescription() {
    (armAway || armStay || disarmStay || disarmOff) ? "Configured" : ""
}

private externalAlarmCruiseDescription() {
    extAlarms ? "Configured" : ""
}

private motionActionsDescription() {
    (recipients || sms || push || alarms || alarmSilent || lights || picture || cameras.any { camera -> settings."cruisemap${camera}" || settings."resetPreset${camera}" }) ? "Configured" : ""
}

private modePresetsDescription() {
    def pieces = ""
    if (individualModePresets) {
        for (camera in cameras) {
            pieces = presetsDescriptionPieces(location.modes, pieces, camera)
        }
    } else {
        pieces = presetsDescriptionPieces(location.modes, pieces)
    }

    return pieces
}

private presencePresetsDescription() {
    def pieces = ""
    if (individualPresencePresets) {
        cameras.each { camera ->
            pieces = presetsDescriptionPieces(settings."peoplePresets", pieces, camera)
        }
    } else {
        pieces = presetsDescriptionPieces(settings."peoplePresets", pieces)
    }

    return pieces
}

private presetsDescriptionPieces(items, pieces, camera = "") {
    items.each { item ->
        def preset = settings."preset${item}${camera}"
        if (preset) {
            if (pieces.length() > 0) {
                pieces += "\n"
            }
            pieces += "${camera ? camera.toString() + ' ' : ''}${item} - ${preset}"
        }/* else {
            if (pieces.length() > 0) {
            	pieces += "\n"
            }
            pieces += "${camera ? camera.toString() + ' ' : ''}${item} - <Not set>"
		}*/
    }
    
    return pieces
}

private getCruiseNames() {
    log.trace "Getting cruise names from camera $cameras"
    def ret = []
    if (cameras) { // There are only 2 cruises on the camera
        ret.add("Horizontal Cruise")
        ret.add("Vertical Cruise")
    }
    log.trace "Cruise names -> ${ret}"
    return ret
}

private getPresetNames(camera = null) {
    log.trace "Getting present names from camera ${camera ?: cameras[0]}"
    def ret = []
    if (cameras) {
        (1..6).each { // Cameras have 6 presets
            (camera ?: cameras[0])."currentPreset${it}" ? ret.add((camera ?: cameras[0])."currentPreset${it}") : ""
        }
    }
    log.trace "Preset names -> ${ret}"
    return ret
}

// Get all installed cameras
private getCameras() {
    def cams = getChildDevices()
    //log.trace "Installed cameras found: $cams"
    return cams
}

// Sends our Foscam discovery packets to discover foscams
private discoverCameras(ip = null) {
    log.trace "Sending discovery${ip ? " for $ip" : ""}"
    
    def hexIP = ip ? convertIPtoHex(ip) : "FFFFFFFF"
    
	//add type UDP_CLIENT
    // ST cannot send packets to Broadcast addresses 255.255.255.255 or 192.168.1.255 so we need to address it to a specific IP
    // When sending Hex data start the pattern with `0b` to tell ST that it's a hex data
	//def action = new physicalgraph.device.HubAction("0b4D4F5F490000000000000000000000040000000400000000000001", physicalgraph.device.Protocol.LAN, "$hexIP:2710")
    // ST also accept ASCII data with embedded UTF-16 for extended ASCII characters
	def action = new physicalgraph.device.HubAction("MO_I\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0001", physicalgraph.device.Protocol.LAN, "$hexIP:2710")
	action.options = [type:"LAN_TYPE_CLIENT", protocol:"LAN_PROTOCOL_UDP", callback: reponseHandler] // Calls the callback handler
	//action.options = [type:"LAN_TYPE_CLIENT", protocol:"LAN_PROTOCOL_UDP"] // Call the subscribed location handler
	sendHubCommand(action)
}

// HubAction call back handler
void reponseHandler(physicalgraph.device.HubResponse hubResponse) {
    log.trace "GOT CALL BACK HANDLER: ${hubResponse}\nDescription: ${hubResponse?.description}\nBody: ${hubResponse?.body}\njson: ${hubResponse?.json?.inspect()}"
    def hub = hubResponse.hubId
    def description = stringToMap(hubResponse.description)
    log.debug "Hub Id: $hub, Description: $description"
    
    parseDiscovery(description, hub)
}

// Subscribed location handler for hubAction when not using callback handler
def locationHandler(evt) {
	/*
	FOSCAM EXAMPLE
	4D4F5F4901000000000000000000006200000000000000 (SOF) //46 (23 bytes)
	30303632364534443042344200 (mac) //26 (13 bytes)
	466F7363616D5F44617274684D61756C0000000000 (name) //42 (21 bytes)
	0A01652C (ip) //8 (4 bytes)
	FFFFFE00 (mask) //8 (4 bytes)
	00000000 (gateway ip) //8 (4 bytes)
	00000000 (dns) //8 (4 bytes)
	01005800 (reserve) //8 (4 bytes)
	01040108 (system software version) //8 (4 bytes)
	020B0106 (app software version) //8 (4 bytes)
	0058 (port) //4 (2 bytes)
	01 (dhcp enabled) //2 (1 byte)
	*/
	def description = evt.description
	def hub = evt?.hubId

	log.trace "GOT LOCATION EVT: $description"

	def parsedEvent = stringToMap(description)
    
    parseDiscovery(parsedEvent, hub)
}

// Parse the discovery response and adds the camera to the list of discovered cameras in the format [dni:[camera details map]]
private parseDiscovery(parsedEvent, hub) {
	//FOSCAM does a UDP response with camera operate protocol:“MO_I” i.e. "4D4F5F49"
	if (parsedEvent?.type == "LAN_TYPE_UDPCLIENT" && parsedEvent?.payload?.startsWith("4D4F5F49")) {
		def unpacked = [:]
		unpacked.mac = parsedEvent.mac.toString()
		unpacked.name = hexToString(parsedEvent.payload[72..113]).trim()
		unpacked.ip = parsedEvent.payload[114..121]
		unpacked.subnet = parsedEvent.payload[122..129]
		unpacked.gateway = parsedEvent.payload[130..137]
		unpacked.dns = parsedEvent.payload[138..145]
		unpacked.reserve = parsedEvent.payload[146..153]
		unpacked.sysVersion = parsedEvent.payload[154..161]
		unpacked.appVersion = parsedEvent.payload[162..169]
		unpacked.port = parsedEvent.payload[170..173]
		unpacked.dhcp = parsedEvent.payload[174..175]
		unpacked.hub = hub
        unpacked.hd = Long.parseLong(unpacked.reserve, 16) ? true : false // the reserved bits are all 0's for older SD cameras, convert from hex string
        log.debug "Found: $unpacked"

		def cams = getDiscoveredCameras()
        //log.debug "Saved cameras: $cams"
		if (!(cams."${unpacked.ip.toString()}:${unpacked.port.toString()}")) { // don't add duplicates
			cams << [("${unpacked.ip.toString()}:${unpacked.port.toString()}"):unpacked] // key is (ip+port) in hex
		//if (!(cams."${unpacked.mac}")) { // don't add duplicates
			//cams << [("${unpacked.mac}"):unpacked] // key is mac
            log.info "Found new camera: ${unpacked}"
		}
	}
}

// Returns a list of discovered cameras in the format given in parseDiscovery()
private getDiscoveredCameras() {
	state.cameras = state.cameras ?: [:]
}

private installCameras() {
    log.trace "Installing cameras"
    
    // discovery search, get hub IP address, the camera needs to be on the same network (workaround for now since broadcast packets don't work with the hub)
    def physicalHubs = location.hubs.findAll { it.type == physicalgraph.device.HubType.PHYSICAL } // Ignore Virtual hubs
    def hub = physicalHubs[0]
    
    // Get cameras with complete configurations
    def installedCams = cameras
	def cams = getNewConfiguredCameras()
	cams.each { cam ->
        def iCam = installedCams.find { cam.dni.toLowerCase() == it.deviceNetworkId.toLowerCase() }
		if (!iCam) {
            try { // This may not succeed
                log.info "Installing camera ${cam.name} installed with device id ${cam.dni}"
                addChildDevice("rboy", "RBoy Foscam IP Camera", cam.dni, hub.id, ["label": cam.name, "preferences": cam.prefs])
            } catch (Exception e) {
                sendPush "Installing camera ${cam.name} failed. Please check for duplicate camera IP address and port."
                log.error "Installing camera ${cam.name} failed. Error $e"
            }
		} else {
			log.warn "Camera ${iCam.displayName} with device id ${cam.dni} already exists, not installing camera"
		}
	}
}

private cleanUpCameras() {
    log.trace "Cleaning up cameras"
    
    // Get installed cameras and delete those marked to be deleted
    def installedCams = cameras
    installedCams.each { iCam ->
        if (settings."delete${iCam.deviceNetworkId}") { // If an installed camera is designated to be deleted
			log.info "Camera ${iCam.displayName} with device id ${iCam.deviceNetworkId} marked for deletion, deleting"
            try {
                deleteChildDevice(iCam.deviceNetworkId)
                deleteSetting("delete${iCam.deviceNetworkId}") // clear the settings so it won't delete it again if reinstalled with same dni
            } catch (Exception e) {
                sendPush "Deleting camera ${iCam.displayName} failed. Please check if camera device is in use by SmartApps"
                log.error "Deleting camera ${iCam.displayName} failed. Error $e"
            }
        }
    }
}

private setCameraToPreset(camera, resetPreset)
{
    (1..6).each { // 6 presets on the camera
        if (camera."currentPreset${it}" == resetPreset) {
            log.debug "Setting camera $camera to preset ${it} -> $resetPreset"
            camera."preset${it}"()
        }
    }
}

private int getActiveAlarmPollPeriod() {
    return 15 // poll 15 seconds
}


// APP STUFF
def installed() {
    log.trace "Installed called"
    initialize()
}

def updated() {
    log.trace "Updated called"
    initialize()
}

def initialize() {
    log.debug "Initialize with settings: ${settings}"

    state.clientVersion = clientVersion() // Update our local stored client version to detect code upgrades

    // Clear pending stuff
    unsubscribe()
    unschedule()

    // NOTE: RANDOM BUG in platform, we can't use subscribe after clean up because it seems to caching it and causing an exception, so clean up after subcribing if it's creating an issue
    // Clean up pending deletions first incase the user is trying to replace a camera with same IP address
    cleanUpCameras()
    
    // First install the cameras
    installCameras()
    runIn(10, refreshAllCameras) // Do it async otherwise the app can timeout
    
    log.debug "Selected Modes: $modeMonitor"

    subscribe(location, "mode", modeChangeHandler)
    subscribe(cameras, "alarmStatus.on", startMonitor)
    subscribe(cameras, "alarmStatus.off", stopMonitor)
    subscribe(cameras, "motion.active", motionDetected)
    subscribe(extAlarms, "alarm", extAlarmNotify)
    subscribe(peoplePresets, "presence.present", arrivalNotify) // People arrival notification
    subscribe(location, "alarmSystemStatus", shmHandler) // SHM Integration

    // Initialize when we are going to check for code version updates
    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        log.error "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
        sendPush "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
    }
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    Calendar localCalendar = Calendar.getInstance(timeZone)
    localCalendar.set(Calendar.DAY_OF_WEEK, randomDayOfWeek)
    localCalendar.set(Calendar.HOUR_OF_DAY, randomHour) // Check for code updates once a week at a random day and time between 10am and 6pm
    localCalendar.set(Calendar.MINUTE, 0)
    localCalendar.set(Calendar.SECOND, 0)
    localCalendar.set(Calendar.MILLISECOND, 0)
    if (localCalendar.getTimeInMillis() < now()) { // If it's in the past add one week to it
        localCalendar.add(Calendar.DAY_OF_YEAR, 7)
    }
    state.nextCodeUpdateCheck = localCalendar.getTimeInMillis()
    log.debug "Checking for next app update after ${(new Date(state.nextCodeUpdateCheck)).format("EEE MMM dd yyyy HH:mm z", timeZone)}"
    
    state.lastMotionMonitorCheck = 0
    state.lastHeartBeat = 0
    
    // Check if any of the camera's have their alarmStatus initialized and as (on or alarm), if so then add them to the list and start the monitoring
    def onCams = [] // Start over incase cameras were removed from the list
    cameras.each { camera ->
        log.debug "Camera $camera type is ${camera.currentAlarmNotifyType} and current motion monitoring status is ${camera.currentValue("alarmStatus")}"
        if ((camera.currentValue("alarmStatus") == "on") || (camera.currentValue("alarmStatus") == "alarm")) {
            if (enablePush && (camera.currentAlarmNotifyType == "Push")) {
                atomicState.usedToken = true // Setup and register a new token
            }
            log.debug "Adding camera $camera.id to the monitor camera list ${onCams}"
            onCams.add(camera.id) // add camera to be monitored
        }
    }
    atomicState.cameraList = onCams // Update the list

    if (onCams.size() > 0) { // If we have any camera's in the list start the monitorTask
        log.debug "Found active cameras in the monitor list, starting monitor task"
        runIn(interval, monitorTask)
    }

    state.subscribe = false // Reset this as we're no longer subscribed to the location events for discovering cameras
}

def refreshAllCameras() {
    cameras.each { cam ->
        cam.refresh() // Refresh each camera to get the latest settings
    }
}

// Integration with SHM
def shmHandler(evt) {
    log.trace "SHM Handler called with state $evt.value"
    
    switch (evt.value) {
        case "stay":
        	if (armStay) {
                log.trace "Enabling All Cameras Motion Detection on Stay"
                cameras*.on()
            } else if (disarmStay) {
                log.trace "Disabling All Cameras Motion Detection on Stay"
                cameras*.off()
            } else {
                log.trace "No action configured for Stay"
            }
            break

        case "away":
        	if (armAway) {
                log.trace "Enabling All Cameras Motion Detection on Away"
                cameras*.on()
            } else {
                log.trace "No action configured for Away"
            }
            break

        case "off":
        	if (disarmOff) {
                log.trace "Disabling All Cameras Motion Detection on Away"
                cameras*.off()
            } else {
                log.trace "No action configured for Away"
            }
            break
            
        default:
            log.error "Invalid SHM state: $evt.value"
            break
    }
}

def startMonitor(event) {
    log.trace "startMonitor called, starting status updated for camera ${event.displayName}"

    def camera = cameras.find { event.deviceId == it.id }
    if (!camera) {
        log.error "Motion even is from Camera ${event.displayName} which is not in the list of actively monitored camera's $cameras, this should not happen"
        return
    }

    if (!(atomicState.cameraList ?: []).contains(camera.id)) {
        log.trace "Adding camera ${camera.id} to monitor camera list ${atomicState.cameraList ?: []}"
        atomicState.cameraList = (atomicState.cameraList ?: []) << (event.device.id) // add camera to be monitored
    }
    else
        log.warn "Camera ${camera} is already in the monitored list"

    if (enablePush && (camera.currentAlarmNotifyType == "Push")) {
        atomicState.usedToken = true // Setup and register a new token
    }
    
    log.trace "Calling monitorTask"
    monitorTask()
}

def stopMonitor(event) {
    // Start with this to avoid a race condition with events flowing in
    log.trace "StopMonitor called for camera ${event.displayName}, removing camera ${event.device.id} from monitor camera list ${atomicState.cameraList ?: []}"
    
    def devMonitored = event.device.id

    atomicState.cameraList = (atomicState.cameraList ?: []) - (devMonitored) // remove camera to stop monitoring
    log.trace "Updated monitor camera list ${atomicState.cameraList ?: []}"

    def camera = cameras.find { event.deviceId == it.id }
    if (!camera) {
        log.error "Motion event is from Camera ${event.displayName} which is not in the list of actively monitored camera's $cameras"
        return
    }

    // Check if the camera is in the list of actively monitored camera (phantom event check)
    if (!devMonitored) {
        log.warn "Received motion event from a camera $camera that no longer being actively monitored"
        return
    }

    //log.trace "Reconfiguring camera $camera"

    // First stop more notifications
    if ((atomicState.cameraList ?: []).size() == 0) {
        log.trace "Stopping monitorTask since there are no cameras to be monitored"
        unschedule(monitorTask)
    }

    if (enablePush && (camera.currentAlarmNotifyType == "Push")) {
        log.debug "Deregistering motion event callback"
        camera.deRegisterMotionCallback()
    }

    // Stop the cruise action if enabled
    if (settings."cruisemap${camera}") {
        log.debug "Stopping cruise on $camera"
        camera.stopCruise()
    }

    if (settings."resetPreset${camera}") {
        log.trace "Settings Reset position ${settings."resetPreset${camera}"} on camera ${camera}"
        setCameraToPreset(camera, settings."resetPreset${camera}")
    }
}

def monitorTask() {
    //log.trace "Monitor task called, monitoring: ${atomicState.cameraList}"

    try { // This can take a long time sometimes, don't let it kill if it times out
        // Hack for broken ST timers - Schedule the Heartbeat
        if (((state.lastHeartBeat ?: 0) + ((1+1)*60*1000)) < now()) { // Since we are scheduling the heartbeat every 1 minutes, give it a 1 minute grace
            log.warn "Heartbeat not called in last 2 minutes, rescheduling heartbeat"
            schedule("* */1 * * * ?", heartBeatMonitor) // run the heartbeat every 1 minutes
            state.lastHeartBeat = now() // give it 1 minutes before you schedule it again
        }

        cameras.each { camera ->
            if ((atomicState.cameraList ?: []).contains(camera.id)) {
                if (!enablePush || (camera.currentAlarmNotifyType == "Pull")) {
                    log.debug "Checking Camera $camera for Active Motion Alarms"
                    camera.checkMotionStatus()
                } else if (atomicState.usedToken) { // Don't send new callback URL if we already have an unused token
                    // Camera will call this URL
                    setupCameraAccessToken() // We need a new URL each time otherwise it caches it and won't work
                    //def callbackURL = "http://graph.api.smartthings.com/api/token/${state.accessToken}/smartapps/installations/${app.id}/Motion/${camera.id}"
                    //def callbackURL = apiServerUrl("/api/token/${state.accessToken}/smartapps/installations/${app.id}/Motion/${camera.id}")
                    def callbackURL = apiServerUrl("/api/smartapps/installations/${app.id}/Motion/${camera.id}?access_token=${state.accessToken}") // As per the new format
                    def shortURL = shortenURL(callbackURL)
                    def visitURL = LongURLService(shortURL)
                    log.debug "Registering Camera Motion Callback URL -> ${URLEncoder.encode(visitURL)}"
                    camera.registerMotionCallback(URLEncoder.encode(visitURL))
                    atomicState.usedToken = false // We now have a new token
                }
            }
        }

        state.lastMotionMonitorCheck = now() // Update the last time we successfully checked for motion events

        if ((atomicState.cameraList ?: []).size() > 0) {
            //log.trace "Monitor camera list ${atomicState.cameraList ?: []}"
            for (camera in cameras) {
                if ((atomicState.cameraList ?: []).contains(camera.id)) {
                    if (!enablePush || (camera.currentAlarmNotifyType == "Pull")) {
                        //log.trace "ReScheduling monitorTask to run in ${interval} seconds"
                        runIn(interval, monitorTask) // runIn has better resolution than runOnce but less reliable given current ST platform status
                        return // done here
                    }
                }
            }
        }
    } catch (e) {
        log.error "Monitor task was unsuccessful, will try again shortly. Error:$e"
        runIn(interval, monitorTask) // try this again and hope it doesn't timeout
    }
}

// Heartbeat system to ensure that the MonitorTask doesn't die when it's supposed to be running
def heartBeatMonitor() {
    log.trace "Heartbeat monitor called"
    
    state.lastHeartBeat = now() // Save the last time we were executed

    // Check if the user has upgraded the SmartApp and reinitailize if required
    if (state.clientVersion != clientVersion()) {
        def msg = "NOTE: ${app.label} detected a code upgrade. Updating configuration, please open the app and click on Save to re-validate your settings"
        log.warn msg
        runIn(1, initialize) // Reinitialize the app offline to avoid a loop as initialize calls heartbeat
        sendNotifications(msg) // Do this in the end as it may timeout
        return
    }

    // Kick start the motion detection monitor if didn't update for more than 30 seconds beyond the polling period
    if ((atomicState.cameraList ?: []).size() > 0) { // If we are supposed to be in monitoring mode
        log.trace "Last motion detection check was done " + ((now() - (state.lastMotionMonitorCheck ?: 0))/1000) + " seconds ago"
        if (((state.lastMotionMonitorCheck ?: 0) + (interval * 1000) + (30*1000)) < now()) { // Give it a 30 second grace period before kick starting it
            log.warn "Motion detection hasn't been run a long time, calling it to kick start it"
            monitorTask()
        }
    }
}

def pollActiveCameras() {
    log.trace "Poll active camera's manually"

    for (camera in cameras) {
        if ((atomicState.cameraList ?: []).contains(camera.id)) {
            log.debug "Manual checking camera $camera for Active Motion Alarms"
            camera.checkMotionStatus()
            if (camera.currentMotion == "active") { // As long as are active keep polling (this function is called from Push mode so we need to track until it's inactive)
                log.trace "Push mode manual poll alarm still active, checking for an status update in ${activeAlarmPollPeriod} seconds"
                runIn(activeAlarmPollPeriod, pollActiveCameras)
                return // We're done here
            }
        }
    }
}

def motionDetected(event) {
    log.info "Motion detected in camera ${event.displayName}"

    def camera = cameras.find { event.deviceId == it.id }
    if (!camera) {
        log.error "Motion event is from Camera ${event.displayName} whic is not in the list of actively monitored camera's $cameras, this should not happen"
        return
    }

    if (modeMonitor && !modeMonitor.contains(location.mode)) { // Empty means all modes
        log.warn "Current mode ${location.mode} is not in the list of active modes $modeMonitor, skipping taking actions on motion detection"
        return
    }

    // Check if the camera is in the list of actively monitored camera (phantom event check)
    if (!(atomicState.cameraList ?: []).contains(camera.id)) {
        log.warn "Received motion event from a camera $camera that no longer being actively monitored"
        return
    }

    log.trace "Camera id ${camera.id}, active camera list ${atomicState.cameraList ?: []}"

    // turn on the alarms
    log.debug "Turning on alarms $alarms, silent: $alarmSilent"
    alarmSilent ? alarms?.strobe() : alarms?.both()

    // turn on lights
    log.debug "Turning on lights $lights"
    lights?.on()
    if (lightTimer) {
        log.trace "Scheduling lights turn off after $lightTimer minutes"
        runIn(lightTimer * 60, turnOffLights)
    }

    // take picture
    if (picture) {
        log.debug "Taking a picture with camera $event.displayName"
        camera.take()
    }

    // turn on cruise
    if (settings."cruisemap${camera}") {
        // Delay for about two seconds before starting the cruise to avoid tearing of the picture
        delayMs(2000)

        if (cruiseNames.findIndexOf { it == settings."cruisemap${camera}" } == 0) {
            camera.horizontalCruise()
            log.debug "Enabling cruise ${settings."cruisemap${camera}"} on camera $camera"
        } else {
            camera.verticalCruise()
            log.debug "Enabling cruise ${settings."cruisemap${camera}"} on camera $camera"
        }
    }

    // Send notifications
    def msg = "${event.displayName} has detected motion"
    sendNotifications(msg)

    // If we are in push mode then we need to manually check in X seconds if the motion alarm notification still exists otherwise nothing will update
    if (enablePush && (camera.currentAlarmNotifyType == "Push")) {
        monitorTask() // Setup the new token URL in the camera
        log.trace "Push mode, checking for an status update in ${activeAlarmPollPeriod} seconds"
        runIn(activeAlarmPollPeriod, pollActiveCameras)
    }
}

def turnOffLights() {
    log.debug "Schedule called, turning off lights $lights"
    lights?.off()
}

def extAlarmNotify(evt) {
    log.info "External alarm ${evt.displayName} set alarm to ${evt.value}"

    // Cruise maps start/stop
    cameras.each { camera -> 
        if (settings."extCruisemap${camera}") { // Check if cruise action is enabled
            if (evt.value == "off") { // turn off cruise
                log.debug "External Alarm turned off, stopping cruise on $camera"
                camera.stopCruise()
            } else { // turn on cruise actions if enabled for all other Alarm modes (strobe/on/both)
                if (cruiseNames.findIndexOf { it == settings."extCruisemap${camera}" } == 0) {
                    camera.horizontalCruise()
                    log.debug "External Alarm ${evt.value}, starting cruise ${settings."extCruisemap${camera}"} on $camera"
                } else {
                    camera.verticalCruise()
                    log.debug "External Alarm ${evt.value}, starting cruise ${settings."extCruisemap${camera}"} on $camera"
                }
            }
        }
    }

    // Reset to preset when the alarms are turned off
    cameras.each { camera -> // reset all cameras
        if (settings."extResetPreset${camera}") {
            if (evt.value == "off") {
                log.trace "Checking reset position ${settings."extResetPreset${camera}"} on camera $camera because External Alarm was turned off"
                setCameraToPreset(camera, settings."extResetPreset${camera}")
            }
        }
    }
}

def modeChangeHandler(evt) {
    def mode = evt.value
    log.info "Mode changed to: ${mode}, reinitializing the Monitor Task and settings camera preset if configured"
    def presetMode
    if (individualModePresets) {
        cameras.each { camera -> // reset individual cameras
            presetMode = settings."preset${mode}${camera}"
            if (presetMode) {
                log.info "Resetting camera $camera to preset $presetMode"
                setCameraToPreset(camera, presetMode)
            }
        }
    } else {
        presetMode = settings."preset${mode}"
        if (presetMode) {
            cameras.each { camera -> // reset all cameras
                log.info "Resetting camera $camera to preset $presetMode"
                setCameraToPreset(camera, presetMode)
            }
        }
    }

    monitorTask() // check if we need to reinitialize the Monitoring

    // We check for a code update once a week
    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        log.error "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
        sendPush "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
    }
    if (now() >= state.nextCodeUpdateCheck) {
        // Before checking for code update, calculate the next time we want to check
        state.nextCodeUpdateCheck = (state.nextCodeUpdateCheck ?: now()) + (7*24*60*60*1000) // 1 week from now
        log.info "Checking for next app update after ${(new Date(state.nextCodeUpdateCheck)).format("EEE MMM dd yyyy HH:mm z", timeZone)}"
        
        checkForCodeUpdate() // Check for code updates
    } else {
        log.trace "Checking for next app update after ${(new Date(state.nextCodeUpdateCheck)).format("EEE MMM dd yyyy HH:mm z", timeZone)}"
    }
}

def arrivalNotify(evt) {
    log.info "$evt.displayName arrived, presence set to $evt.value"
    def person = evt.device
    def presetMode
    if (individualPresencePresets) {
        cameras.each { camera -> // reset individual cameras
            presetMode = settings."preset${person}${camera}"
            if (presetMode) {
                log.info "Resetting camera $camera to preset $presetMode"
                setCameraToPreset(camera, presetMode)
            }
        }
    } else {
        presetMode = settings."preset${person}"
        if (presetMode) {
            cameras.each { camera -> // reset all cameras
                log.info "Resetting camera $camera to preset $presetMode"
                setCameraToPreset(camera, presetMode)
            }
        }
    }

    monitorTask() // check if we need to reinitialize the Monitoring  
}

// OAuth Configuration for Push Camera incoming Web notifications for motion alarms
mappings {
    path("/Motion/:cameraId") {
        action: [
            GET: "cameraMotionCallback"
        ]
    }
}

// OAuth call back from external REST webservice
def cameraMotionCallback() {
    log.info "Received motion detected callback for camera Id ${params.cameraId} with params -> $params"

    def camera = cameras?.find { camera -> camera.id == params.cameraId }
    if (camera) {
        log.info "Motion Detected on Camera $camera"

        // Check if the camera is in the list of actively monitored camera (phantom event check)
        if (!(atomicState.cameraList ?: []).contains(camera.id)) {
            log.warn "Received motion event from a camera $camera that is no longer being actively monitored"
            return // Done here
        }

        atomicState.usedToken = true // We now have a used token, set before callback so it'll generate a new token
        camera.motionCallbackNotify() // Let the device know we got a callback notification
    } else {
        log.warn "Received motion event from a camera $camera that is no longer being actively monitored"
    }
}

private setupCameraAccessToken() {
    log.trace "Creating Access Token for call back" // For security purposes each time we initialize we create a new token
    try {
        revokeAccessToken() // First kill the old tokens
        createAccessToken() // Now create a new token
    } catch (e) {
        log.error "Error creating access token, have you ENABLED OAuth in the SmartApp Settings?"
        sendPush "Error creating access token, have you ENABLED OAuth in the SmartApp Settings?"
        log.error "Error : $e"
        return
    }

    // Each Camera will call this URL with their Id's
    cameras.each { camera ->
        //def callbackURL = "http://graph.api.smartthings.com/api/token/${state.accessToken}/smartapps/installations/${app.id}/Motion/${camera.id}"
        //def callbackURL = apiServerUrl("/api/token/${state.accessToken}/smartapps/installations/${app.id}/Motion/${camera.id}")
        def callbackURL = apiServerUrl("/api/smartapps/installations/${app.id}/Motion/${camera.id}?access_token=${state.accessToken}") // New format per documentation
        
        log.trace "Camera $camera Motion Callback URL -> $callbackURL"
    }
}

// Shorten the URL since Foscam cameras cannot handle a URL greater than 128 characters
private String shortenURL(longURL) {
    def params = [
        uri: 'http://tiny-url.info/api/v1/create',
        contentType: 'application/json',
        query: [apikey:'D4AG7G09FA819E00F77C', provider: 'tinyurl_com', format: 'json', url: longURL]
    ]

    try {
        httpGet(params) { response ->
            //log.trace "Request was successful, data=$response.data, status=$response.status"
            if (response.data.state == "ok") {
                log.trace "Short URL: ${response.data.shorturl}"
                log.trace "Long URL: ${response.data.longurl}"
                return response.data.shorturl
            } else {
                log.error "Error in return short URL: ${response.data}"
            }
        }
    } catch (e) {
        log.error "Error getting shortened URL: $e"
    }
}

// This service when called visits the shortURL to lengthen it and in the process activates the link
private String LongURLService(shortURL) {
    def visitURL = "http://getlinkinfo.com/info?link=" + shortURL
    log.trace "Visit URL: $visitURL"
    return visitURL
}

// Executes a delay in ms
private delayMs(delay) {
    if (!delay) { return }
    def end = now() + delay
    while (now() <= end) { }
}

private void sendText(number, message) {
    if (number) {
        def phones = number.split("\\*")
        for (phone in phones) {
            sendSms(phone, message)
        }
    }
}

private void sendNotifications(message) {
	if (!message) {
		return
    }
    
    if (location.contactBookEnabled) {
        sendNotificationToContacts(message, recipients)
    } else {
        if (push) {
            sendPush message
        } else {
            sendNotificationEvent(message)
        }
        if (sms) {
            sendText(sms, message)
        }
    }
    if (audioDevices) {
        audioDevices*.playTextAndResume(message)
    }
}

private String hexToString(String txtInHex)
{
	byte [] txtInByte = new byte [txtInHex.length() / 2];
	int j = 0;
	for (int i = 0; i < txtInHex.length(); i += 2)
	{
			txtInByte[j++] = Byte.parseByte(txtInHex.substring(i, i + 2), 16);
	}
	return new String(txtInByte);
}

private boolean isIPAddress(String ipAddress)
{
    try
    {
         String[] parts = ipAddress.split("\\.")
         if (parts.length != 4) {
         	return false
         }
         for (int i = 0; i < 4; ++i)
         {
             int p = Integer.parseInt(parts[i])
             if (p > 255 || p < 0) {
             	return false
             }
         }
         return true
    } catch (Exception e)
    {
        return false
    }
}

private String convertIPtoHex(ipAddress) {
	// Check for valid IPv4 address, ST doesn't support IPv6 yet
    if (!isIPAddress(ipAddress)) {
        log.error "Invalid IP Address $ipAddress, check your settings!"
        return
    }
    
	try {
        String hex = ipAddress.tokenize( '.' ).collect {  String.format('%02x', it.toInteger() ) }.join()  // thanks to @pstuart
        return hex
    } catch (Exception e) {
        log.error "Invalid IP Address $ipAddress, check your settings! Error: $e"
    }
}

private String convertPortToHex(port) {
	if (!port) {
    	log.error "Invalid port $port, check your settings!"
    }
    
    try {
        String hexport = port.toString().format('%04x', port.toInteger() )   // thanks to @pstuart
        return hexport
    } catch (Exception e) {
        log.error "Invalid port $port, check your settings! Error: $e"
    }
}

private Integer convertHexToInt(hex) {
    convertHexToPort(hex)
}

private Integer convertHexToPort(hex) {
	if (!hex) {
    	log.error "Invalid hex port $hex, check your settings!"
    }
    
	Integer.parseInt(hex,16)
}

private String convertHexToIP(hex) {
	if (!hex) {
    	log.error "Invalid hex ip $hex, check your settings!"
    }
    
	[convertHexToInt(hex[0..1]),convertHexToInt(hex[2..3]),convertHexToInt(hex[4..5]),convertHexToInt(hex[6..7])].join(".")
}

// Temporarily override the user settings
private updateSetting(name, value) {
    app.updateSetting(name, value) // For SmartApps UI - THIS IS A VERY SLOW TRANSACTION as it writes directly to the DB
    settings[name] = value // For Device Handlers and SmartApps - much faster but only works on uninitialized value (once the user updates it this approach won't work)
}

private deleteSetting(name) {
    //app.deleteSetting(name) // For SmartApps delete it, TODO: Gives and error - THIS IS A VERY SLOW TRANSACTION as it writes directly to the DB (don't mix app and settings approach or it causes corruption)
    //settings.remove(name) // For Device Handlers
    app.updateSetting(name, '') // For SmartApps - THIS IS A VERY SLOW TRANSACTION as it writes directly to the DB (don't mix app and settings approach or it causes corruption)
    settings[name] = '' // For Device Handlers and SmartApps - much faster but only works on uninitialized value (once the user updates it this approach won't work)
}

def checkForCodeUpdate(evt) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "Foscam Motion Alarm Monitor"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (updateNotifications != false) { // The default true may not be registered
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def caps = [ cameras, alarms, lights, extAlarms ]
                caps?.each {
                    def devices = it?.findAll { it.hasAttribute("codeVersion") }
                    for (device in devices) {
                        if (device) {
                            def deviceName = device?.currentValue("dhName")
                            def deviceVersion = ret.data?."$deviceName"
                            if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                                def msg = "New version of device ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                                log.info msg
                                if (updateNotifications != false) { // The default true may not be registered
                                    sendPush(msg)
                                }
                            } else {
                                log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                            }
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}

// THIS IS THE END OF THE FILE